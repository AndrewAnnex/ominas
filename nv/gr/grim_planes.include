;=============================================================================
; grim_crop_plane
;
;=============================================================================
pro grim_crop_plane, grim_data, plane

 
 ;----------------------------------------------
 ; plot: crop to visible xrange
 ;----------------------------------------------
 if(grim_data.type EQ 'plot') then $
  begin
   tvgr, grim_data.wnum, get=tvd
   xrange = tvd.xrange

   dat = nv_data(plane.dd)
   x = dat[0,*]
   w = where((x GE xrange[0]) AND (x LE xrange[1]))

   dat = dat[*,w]
   nv_set_data, plane.dd, dat
  end $
 ;----------------------------------------------
 ; image: crop to visible size
 ;----------------------------------------------
 else $
  begin
   p0 = [0,0] & p1 = [!d.x_size, !d.y_size]-1
   pp0 = round((convert_coord(/device, /to_data, p0))[0:1])
   pp1 = round((convert_coord(/device, /to_data, p1))[0:1])

   im = nv_data(plane.dd)
   dim = size(im, /dim)

   xmin = min([pp0[0],pp1[0]])
   xmax = max([pp0[0],pp1[0]])
   ymin = min([pp0[1],pp1[1]])
   ymax = max([pp0[1],pp1[1]])

   xxmin = xmin>0
   xxmax = xmax<dim[0]-1
   yymin = ymin>0
   yymax = ymax<dim[1]-1

   im = im[xxmin:xxmax, yymin:yymax]

   tvim, grim_data.wnum, offset=[0,0], zoom=!d.x_size/float(xmax-xmin)

   nv_set_data, plane.dd, im
  end


end
;=============================================================================



;=============================================================================
; grim_next_plane
;
;=============================================================================
pro grim_next_plane, grim_data, norefresh=norefresh

; if(NOT keyword_set(grim_data)) then grim_data = grim_get_data()

 ;-----------------------------------
 ; change to next valid plane
 ;-----------------------------------
 flags = *grim_data.pl_flags_p

 repeat $
  begin
   grim_data.pn = grim_data.pn + 1
   if(grim_data.pn EQ grim_data.n_planes) then grim_data.pn = 0
  endrep until(flags[grim_data.pn] NE 0)

 grim_set_data, grim_data

 no_erase = 1 
 if(grim_data.type EQ 'plot') then no_erase = 0
 
 if(NOT keyword_set(norefresh)) then grim_refresh, grim_data, no_erase=no_erase, /noglass

 grim_call_plane_callbacks, grim_data
end
;=============================================================================



;=============================================================================
; grim_previous_plane
;
;=============================================================================
pro grim_previous_plane, grim_data

 ;-----------------------------------
 ; change to next valid plane
 ;-----------------------------------
 flags = *grim_data.pl_flags_p

 repeat $
  begin
   grim_data.pn = grim_data.pn - 1
   if(grim_data.pn EQ -1) then grim_data.pn = grim_data.n_planes-1
  endrep until(flags[grim_data.pn] NE 0)

 grim_set_data, grim_data

 no_erase = 1 
 if(grim_data.type EQ 'plot') then no_erase = 0
 
 grim_refresh, grim_data, no_erase=no_erase, /noglass
 grim_call_plane_callbacks, grim_data
end
;=============================================================================



;=============================================================================
; grim_get_plane
;
;=============================================================================
function grim_get_plane, grim_data, all=all, pn=pn, visible=visible

 if(keyword_set(all)) then $
  begin
   flags = *grim_data.pl_flags_p
   pn = where(flags NE 0)
   if(pn[0] EQ -1) then return, 0
  end 

 if(n_elements(pn) NE 0) then return, (*grim_data.planes_p)[pn]

 return, (*grim_data.planes_p)[grim_data.pn]
end
;=============================================================================



;=============================================================================
; grim_plane_set_visible
;
;=============================================================================
pro grim_plane_set_visible, grim_data, planes, val, toggle=toggle

 if(keyword_set(toggle)) then $
  begin
   w = where(planes.visible EQ 1)
   ww = where(planes.visible EQ 0)
   if(w[0] NE -1) then planes[w].visible = 0
   if(ww[0] NE -1) then planes[ww].visible = 1
  end $
 else planes.visible = val

 grim_set_plane, grim_data, planes, pn=planes.pn
end
;=============================================================================



;=============================================================================
; grim_get_visible_planes
;
;=============================================================================
function grim_get_visible_planes, grim_data

 plane = grim_get_plane(grim_data)
 all_planes = grim_get_plane(grim_data, /all)
 w = where(all_planes.visible)

 if(NOT plane.visible) then planes = plane
 if(w[0] NE -1) then planes = append_array(planes, all_planes[w])

 return, planes
end
;=============================================================================



;=============================================================================
; grim_set_plane
;
;=============================================================================
pro grim_set_plane, grim_data, plane, pn=pn

 if(NOT ptr_valid(grim_data.planes_p)) then return

 if(n_elements(pn) NE 0) then (*grim_data.planes_p)[pn] = plane $
; else (*grim_data.planes_p)[grim_data.pn] = plane
 else (*grim_data.planes_p)[plane.pn] = plane

end
;=============================================================================



;=============================================================================
; grim_rm_plane
;
;=============================================================================
pro grim_rm_plane, grim_data, pn

 ;---------------------------------------------------------------
 ; if this is the only plane, then exit
 ;---------------------------------------------------------------
 w = where(*grim_data.pl_flags_p EQ 1)
 if(n_elements(w) EQ 1) then $
  begin
   grim_exit, grim_data
   return
  end

 ;---------------------------------------------------------------
 ; mark the specified plane as inactive
 ;  NOTE:  The data for the plane still exists and may continue
 ;         to be used from the command line.
 ;---------------------------------------------------------------
 plane = grim_get_plane(grim_data, pn=pn)
 plane.pn = -1
 grim_set_plane, grim_data, plane, pn=pn

 (*grim_data.pl_flags_p)[pn] = 0

 ;---------------------------------------------------------------
 ; change to a valid plane
 ;---------------------------------------------------------------
 grim_previous_plane, grim_data
 grim_refresh, grim_data


end
;=============================================================================



;=============================================================================
; grim_init_parms
;
;=============================================================================
function grim_init_parms, n, color=color, thick=thick, nsum=nsum, psym=psym, $
                          symsize=symsize


 _parm = {grim_parm_data_struct, $
		color:		ctwhite(), $
		thick:		1l, $
		nsum:		0, $
		symsize:	1., $
		psym:		-3l $
              }

 parm = replicate(_parm, n)

 if(keyword__set(color)) then parm.color = color
 if(keyword__set(thick)) then parm.thick = thick
 if(keyword__set(nsum)) then parm.nsum = nsum
 if(keyword__set(psym)) then parm.psym = psym
 if(keyword__set(symsize)) then parm.symsize = symsize

 return, parm
end
;=============================================================================



;=============================================================================
; grim_clone_plane
;
; This is a crappy implementation
;
;=============================================================================
function grim_clone_plane, grim_data, plane=plane

 grim_add_planes, grim_data, plane.dd, pn=pn

 new_plane = nv_clone(plane)

 new_plane.pn = pn
 (*grim_data.planes_p)[pn] = new_plane

  new_plane.cmd = colormap_descriptor(data=new_plane.pn, $
                                n_colors=grim_n_colors(nv_type(new_plane.dd)))

 grim_set_plane, grim_data, new_plane
 grim_set_data, grim_data

 return, new_plane
end
;=============================================================================



;=============================================================================
; grim_add_planes
;
;=============================================================================
pro grim_add_planes, grim_data, dd, pns=pns, filter=filter, fov=fov, hide=hide, $
                      path=path, save_path=save_path, load_path=load_path, $
                      trs_cd=trs_cd, trs_pd=trs_pd, trs_rd=trs_rd, trs_sd=trs_sd, trs_std=trs_std, trs_ard=trs_ard, $
                      trs_sund=trs_sund, color=color, xrange=_xrange, yrange=_yrange, $
                      thick=thick, nsum=nsum, xtitle=xtitle, ytitle=ytitle, $
                      psym=psym, symsize=symsize, max=max, visibility=visibility, $
                      render_sample=render_sample, render_pht_min=render_pht_min

  pns = 0

  if(NOT keyword_set(max)) then max = 0

  if(NOT keyword_set(fov)) then fov = grim_data.def_fov
  if(NOT keyword_set(hide)) then hide = grim_data.def_hide
  if(NOT keyword_set(filter)) then filter = grim_data.def_filter
  if(NOT keyword_set(visibility)) then visibility = 0
  if(NOT defined(render_pht_min)) then render_pht_min = 0.02
  if(NOT keyword_set(render_sample)) then render_sample = 1

  if(NOT keyword_set(filetype)) then filetype = grim_data.def_filetype

  if(NOT keyword_set(load_path)) then load_path = grim_data.def_load_path
  if(NOT keyword_set(save_path)) then save_path = grim_data.def_save_path

  if(NOT keyword_set(trs_cd)) then trs_cd = grim_data.def_trs_cd
  if(NOT keyword_set(trs_pd)) then trs_pd = grim_data.def_trs_pd
  if(NOT keyword_set(trs_rd)) then trs_rd = grim_data.def_trs_rd
  if(NOT keyword_set(trs_sd)) then trs_sd = grim_data.def_trs_sd
  if(NOT keyword_set(trs_std)) then trs_std = grim_data.def_trs_std
  if(NOT keyword_set(trs_ard)) then trs_ard = grim_data.def_trs_ard
  if(NOT keyword_set(trs_sund)) then trs_sund = grim_data.def_trs_sund

  if(NOT keyword_set(color)) then color = grim_data.def_color
  if(NOT keyword_set(thick)) then thick = grim_data.def_thick
  if(NOT keyword_set(nsum)) then nsum = grim_data.def_nsum
  if(NOT keyword_set(psym)) then psym = grim_data.def_psym
  if(NOT keyword_set(symsize)) then symsize = grim_data.def_symsize

  if(NOT keyword_set(title)) then title = grim_data.def_title
  if(NOT keyword_set(xtitle)) then xtitle = grim_data.def_xtitle
  if(NOT keyword_set(ytitle)) then ytitle = grim_data.def_ytitle

  xrange = [0.,0.]
  yrange = [0.,0.]
  if(keyword_set(_xrange)) then xrange = _xrange
  if(keyword_set(_yrange)) then yrange = _yrange

  ;--------------------------
  ; plot parms data structure
  ;--------------------------
  n = n_elements(dd)
  parm = grim_init_parms(n, color=color, thick=thick, nsum=nsum, psym=psym, symsize=symsize)


  ;--------------------------------
  ; 8 or 24-bit display?
  ;--------------------------------
;n_colors = 256
;  ctmod, visual=visual
;  if(visual EQ 8) then n_colors = !d.n_colors $
;  else if(visual EQ 24) then n_colors = 256 $
;  else message, 'Only 8 and 24-bit displays supported.'


  window, /free, /pix, xs=1, ys=1	; necessary to allocate color table
  ctmod, top=top

  ;---------------------
  ; planes
  ;---------------------
  planes = *grim_data.planes_p
  flags = *grim_data.pl_flags_p

  n_planes = n_elements(dd) 

  if(n_elements(xtitle) EQ 1) then xtitle = make_array(n_planes, val=xtitle)
  if(n_elements(ytitle) EQ 1) then ytitle = make_array(n_planes, val=ytitle)
  if(n_elements(title) EQ 1) then title = make_array(n_planes, val=title)

  for i=0, n_planes-1 do $
   begin
    flag = 1
    if(nv_id_string(dd[i]) EQ 'BLANK') then flag = 2

    plane = {grim_planes_struct, $
	;---------------
	; bookkeeping
	;---------------
		pn		:	-1, $
		grnum		:	grim_data.grnum, $
		filename	:	'', $
		filter		:	filter, $
		filetype	:	filetype, $
		load_path	:	load_path, $
		save_path	:	save_path, $
		rendering	:	0, $
		render_sample	:	render_sample, $
		render_pht_min	:	render_pht_min, $
		render_show	:	1b, $
		visible		:	0, $		; overlays always visible?
		image_visible	:	0, $
		cradec		:	dblarr(1,3), $
		dradec		:	dblarr(1,3), $
		max		:	double(max), $
		t0		:	0d, $		; last cd time, $

	;---------------
	; plot viewing
	;---------------
		xrange		:	xrange, $
		yrange		:	yrange, $
		position	:	[0.,0.,0.,0.], $
		title		:	title[i], $
		xtitle		:	xtitle[i], $
		ytitle		:	ytitle[i], $
		parm		:	parm[i], $

	;---------------
	; descriptors
	;---------------
		dd		:	dd[i], $		; Data descriptor
		sibling_dd	:	ptr_new(), $		; Last sibling dd
		cd_p		:	ptr_new(ptr_new()), $	; Camera descriptor
		pd_p		:	ptr_new(ptr_new()), $	; Planet descriptors
		rd_p		:	ptr_new(ptr_new()), $	; Ring descriptors
		sd_p		:	ptr_new(ptr_new()), $	; Star descriptors
		sund_p		:	ptr_new(ptr_new()), $	; Sun descriptor
		std_p		:	ptr_new(ptr_new()), $	; Station descriptors
		ard_p		:	ptr_new(ptr_new()), $	; Array descriptors
		od_p		:	ptr_new(ptr_new()), $	; Observer descriptor

	;----------------------------
	; active objects
	;----------------------------
		active_xd_p	:	ptr_new(ptr_new()), $	; Descriptors of
								;  active objects
		active_overlays_psp :	ptr_new(ptr_new()), $	; Active overlays

		active_user_tags_p	:	ptr_new(''), $	

	;-----------------------------------------------------------
	; overlay points arrays -- 
	;  Each overlay array, *overlay_psps[i], has dimensions
	;  (nps, nd), where nd is the number of descriptors 
	;  (planets, rings, etc.) and nps is the number of arrays per
	;  descriptor (e.g., rings have two arrays per descriptor).
	;-----------------------------------------------------------
		overlay_psps		:	ptr_new(0), $
		overlay_names_p		:	ptr_new(''), $
		overlay_classes_p	:	ptr_new(0), $
		overlay_dep_p		:	ptr_new(0), $
		overlay_labels_p	:	ptr_new(0), $
		overlay_color_p		:	ptr_new(''), $
		overlay_psym_p		:	ptr_new(0), $
		overlay_symsize_p	:	ptr_new(0.), $ 
		overlay_shade_p		:	ptr_new(0.), $ 
		overlay_tlab_p		:	ptr_new(0b), $
		overlay_tshade_p	:	ptr_new(0b), $
		overlay_tfill_p		:	ptr_new(0b), $
		overlay_data_p		:	ptr_new(0), $
		override_color		:	'', $

;	;-----------------------------------------------------------
;	; fill arrays
;	;-----------------------------------------------------------
;		fill_poly_psps		:	ptr_new(0), $
;		fill_color_p		:	ptr_new(0), $
;		fill_names_p		:	ptr_new(''), $

	;-----------------------------------------------------------
	; special arrays
	;-----------------------------------------------------------
		roi_p		:	ptr_new(0), $
		roi_ps		:	ps_init(), $
		star_labels_p	:	ptr_new(0), $
		mask_p		: 	ptr_new(-1), $
		tie_psp		: 	ptr_new(ptr_new()), $
		curve_psp	: 	ptr_new(ptr_new()), $
		user_ps_tlp	:	ptr_new(), $	
		notes_p		:	ptr_new(''), $

	;-----------------
	; stretch
	;-----------------
		cmd		:	{colormap_descriptor}, $

	;-------------------
	; image visibility
	;-------------------
		rgb		:	[1b,1b,1b], $ 	; 1=selected
		visibility	:	byte(visibility), $		; 0=normal, 1=always

	;-----------------
	; points settings
	;-----------------
		hide		:	byte(hide), $
		fov		:	float(fov), $
		trs_cd		:	trs_cd, $ 
		trs_pd		:	trs_pd, $ 
		trs_rd		:	trs_rd, $ 
		trs_sd		:	trs_sd, $ 
		trs_std		:	trs_std, $ 
		trs_ard		:	trs_ard, $ 
		trs_sund	:	trs_sund $ 
	     }


    new = 0
    if(NOT keyword__set(planes)) then new = 1 $
    else if(nv_id_string(planes[0].dd) EQ 'BLANK') then new = 1

    ;------------------------------------------------
    ; the first non-blank plane --
    ;------------------------------------------------
    if(new) then $
     begin
      planes = plane
      pn = 0
      pns = [pn]
      flags = flag
     end $
    else $
    ;------------------------------------------------
    ; an additional plane
    ;------------------------------------------------
     begin
      w = where(flags EQ 0)
      ;------------------------------------------------
      ; replace a defunct plane ...
      ;------------------------------------------------
      if(w[0] NE -1) then $
       begin
        pn = w[0]
        planes[pn] = plane
        flags[pn] = flag
       end $
      ;------------------------------------------------
      ; append plane at end of list ...
      ;------------------------------------------------
      else $
       begin
        planes = [planes, plane]
        flags = [flags, flag]
        pn = n_elements(planes) - 1
       end

      if(NOT keyword__set(pns)) then pns = [pn] $
      else pns = [pns, pn]
     end

    planes[pn].pn = pn

    ;--------------------------------------------
    ; create colormap
    ;--------------------------------------------
    planes[pn].cmd = colormap_descriptor(data=planes[pn].pn, $
                                n_colors=grim_n_colors(nv_type(planes[pn].dd)))

    ;--------------------------------------------
    ; create overlay arrays
    ;--------------------------------------------
    grim_create_overlays, grim_data, plane
   end



 planes.image_visible = 1

 grim_data.n_planes = n_elements(planes)
 *grim_data.planes_p = planes
 *grim_data.pl_flags_p = flags

end
;=============================================================================



