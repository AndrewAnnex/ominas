;=============================================================================
; grim_visible_planes
;
;=============================================================================
function grim_visible_planes, grim_data, plane=plane, current=current
 
 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 if(keyword_set(current)) then return, plane
 planes = grim_get_plane(grim_data, /all)

 vis = planes.visibility
 vis[plane.pn] = 1
 w = where(vis EQ 1)


 return, planes[w]
end
;=============================================================================



;=============================================================================
; grim_get_plane_by_xy
;
;=============================================================================
function grim_get_plane_by_xy, grim_data, xy

 planes = grim_visible_planes(grim_data)
 nplanes = n_elements(planes)

 for i=0, nplanes-1 do $
  begin
   im = nv_data(planes[i].dd);, sample=*grim_data.vpp)
   w = where(im NE 0)
   ww = xy_to_w(im, round(xy))

   www = where(w EQ ww[0])

   if(www[0] NE -1) then return, planes[i]
  end

 return, planes[grim_data.pn]
end
;=============================================================================



;=============================================================================
; grim_test_single_channel
;
;=============================================================================
function grim_test_single_channel, grim_data
 if(NOT keyword_set(grim_data)) then grim_data = grim_get_data(/primary)

 planes = grim_visible_planes(grim_data)
 rgb = planes.rgb

 return, total(rgb) EQ n_elements(planes)*3
end
;=============================================================================



;=============================================================================
; grim_load_maps
;
;=============================================================================
pro grim_load_maps, grim_data

 mapdir = getenv('GRIM_MAPS')
 if(NOT keyword_set(mapdir)) then $
  begin
   grim_print, grim_data, 'GRIM_MAPS variable not defined.'
   return
  end 

 files = findfile(mapdir + '/*')

 dd_map = nv_read(files, maintain=1)
 if(NOT keyword_set(dd_map)) then return
 nmap = n_elements(dd_map)

 md_map = ptrarr(nmap)
 for i=0, nmap-1 do md_map[i] = pg_get_maps(dd_map[i])

 w = where(ptr_valid(md_map))
 if(w[0] NE -1) then $
  begin
   *grim_data.dd_map_p = dd_map[w]
   *grim_data.md_map_p = md_map[w]
  end

end
;=============================================================================



;=============================================================================
; grim_associate_maps
;
;=============================================================================
pro grim_associate_maps, grim_data, plane=plane

 map_names = cor_name(*grim_data.md_map_p)

 ;-----------------------------------------
 ; associate planet maps
 ;-----------------------------------------
 if(keyword_set(*plane.pd_p)) then $
  begin
   names = cor_name(*plane.pd_p)
   n = n_elements(names)
   *plane.dd_pd_p = ptrarr(n)
   *plane.md_pd_p = ptrarr(n)
   w = nwhere(names, map_names)
   if(w[0] NE -1) then $
    begin
     (*plane.dd_pd_p)[w] = (*grim_data.dd_map_p)[w]
     (*plane.md_pd_p)[w] = (*grim_data.md_map_p)[w]
    end
  end


 ;-----------------------------------------
 ; associate ring maps
 ;-----------------------------------------
 if(keyword_set(*plane.rd_p)) then $
  begin
   names = cor_name(*plane.rd_p)
   n = n_elements(names)
   *plane.dd_rd_p = ptrarr(n)
   *plane.md_rd_p = ptrarr(n)
   w = nwhere(names, map_names)
   if(w[0] NE -1) then $
    begin
     (*plane.dd_rd_p)[w] = (*grim_data.dd_map_p)[w]
     (*plane.md_rd_p)[w] = (*grim_data.md_map_p)[w]
    end
  end

end
;=============================================================================



;=============================================================================
; grim_render_image
;
;=============================================================================
function grim_render_image, grim_data, plane=plane

 ;-----------------------------------------
 ; load relevant descriptors
 ;-----------------------------------------
 grim_suspend_events
 cd = grim_get_cameras(grim_data, plane=plane)
 pd = grim_get_planets(grim_data, plane=plane)
 rd = grim_get_rings(grim_data, plane=plane)
 sund = grim_get_sun(grim_data, plane=plane)
 grim_resume_events


 ;-----------------------------------------
 ; load maps
 ;-----------------------------------------
 if(NOT keyword_set(*grim_data.dd_map_p)) then grim_load_maps, grim_data


 ;-----------------------------------------
 ; associate maps for this plane
 ;-----------------------------------------
 if(NOT keyword_set(*plane.dd_pd_p)) then grim_associate_maps, grim_data, plane=plane
; NOTE: will need to reassociate if descriptors unloaded and reloaded


 ;-----------------------------------------
 ; render
 ;-----------------------------------------
 map = render(cd=cd, gbx=pd, dkx=rd, sund=sund, pht=0.05, $
                 dd_gbx=*plane.dd_pd_p, md_gbx=*plane.md_pd_p, $
                 dd_dkx=*plane.dd_rd_p, md_dkx=*plane.md_rd_p)

 return, map
end
;=============================================================================



;=============================================================================
; grim_image
;
;=============================================================================
function grim_image, grim_data, _data, plane=plane, pn=pn, colormap=colormap, $
                     channel=channel, current=current, xrange=xrange, yrange=yrange

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 ;---------------------------------------
 ; get all visible planes
 ;---------------------------------------
 planes = grim_visible_planes(grim_data, current=current, plane=plane)
 rgb = planes.rgb


 ;---------------------------------------
 ; get appropriate channel if specified
 ;---------------------------------------
 if(defined(channel)) then $
  begin
   w = where(rgb[channel,*] EQ 1)
   if(w[0] EQ -1) then return, 0
   planes = planes[w]
  end
 nplanes = n_elements(planes)


 ;---------------------------------------
 ; superimpose images
 ;---------------------------------------
 ctmod, top=top
 if(keyword_set(top)) then n_colors = top+1

 dim = nv_dim(plane.dd)

 ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 ; if data ranges given, set up a 1:1 output image covering only the 
 ; given range
 ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 if(keyword_set(xrange)) then $
  begin
   data_size = [xrange[1]-xrange[0]+1, yrange[1]-yrange[0]+1]
   data_x =  (lindgen(data_size[0]) + xrange[0]) # make_array(data_size[1], val=1l)
   data_y =  (lindgen(data_size[1]) + yrange[0]) ## make_array(data_size[0], val=1l)
   ndata = n_elements(data_x)
   data_xy = [reform(data_x, 1, ndata, /over), $
              reform(data_y, 1, ndata, /over)]
   vp = xy_to_w(dim, data_xy)
   device_size = data_size
   vpi = lindgen(ndata)
  end $ 
 ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 ; otherwise construct the output image over the current viewing area
 ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 else $
  begin
   vp = get_viewport_indices(dim, device_indices=vpi, device_size=device_size)
   *grim_data.vpp = vp
  end

 if(n_elements(vp) EQ 1) then return, 0

 ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 ; construct output image by considering only unique data coords and
 ; averaging all visible planes
 ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 uu = unique(vp, rev=ii)
 uvp = vp[uu]

 for i=0, nplanes-1 do $
  begin
   colormap = compute_colormap(planes[i].cmd, n_colors=n_colors)

   if(grim_data.type EQ 'render') then $
                    _im = grim_render_image(grim_data, plane=plane) $
   else _im = nv_data(planes[i].dd, sample=uvp)

   if(plane.max EQ 0) then plane.max = estimate_max(_im)

   if(NOT grim_test_single_channel(grim_data)) then $
                 if(keyword_set(channel)) then _channel=channel
   _im = apply_colormap(_im, colormap, channel=_channel, max=plane.max, min=0)

   if(i EQ 0) then $
    begin
     im = _im
     weight = fix(_im<1)
    end $
   else $
    begin
     im = im + _im
     weight = weight + fix(_im<1)
    end

   grim_set_plane, grim_data, plane
  end

 w = where(weight EQ 0)
 if(w[0] NE -1) then weight[w] = 1

 im = im / weight

 if(grim_data.type EQ 'render') then image = im $
 else $
  begin
   image = make_array(type=size(im, /type), dim=device_size)
   image[vpi] = im[ii]
  end

 return, image
end
;=============================================================================



;=============================================================================
; grim_scale_image
;
;=============================================================================
function grim_scale_image, grim_data, data, r, g, b, current=current, $
     plane=plane, no_scale=no_scale, top=top, xrange=xrange, yrange=yrange

 ;------------------------------------------------------
 ; test for single-channel
 ;------------------------------------------------------
 if(grim_test_single_channel(grim_data)) then $
   image = grim_image(grim_data, data, plane=plane, current=current, xrange=xrange, yrange=yrange) $

 ;------------------------------------------------------------------
 ; otherwise display according to current channel settings 
 ;------------------------------------------------------------------
 else $
  begin
   ctmod, visual=visual

   red = grim_image(grim_data, data, channel=0, current=current, xrange=xrange, yrange=yrange)
   grn = grim_image(grim_data, data, channel=1, current=current, xrange=xrange, yrange=yrange)
   blu = grim_image(grim_data, data, channel=2, current=current, xrange=xrange, yrange=yrange)     

   ;---------------------------------------
   ; pseudo-color (8-bit) display
   ;---------------------------------------
   if(visual EQ 8) then $
    begin
     image = color_quan(red, grn, blu, r, g, b)
     tvlct, r, g, b
     no_scale = 1
    end $
   ;---------------------------------------
   ; otherwise assume decomposed colors
   ;---------------------------------------
   else $
    begin
     sr = size(red, /dim)
     if(NOT keyword_set(red)) then sr = [0l,0l]
     sg = size(grn, /dim)
     if(NOT keyword_set(grn)) then sg = [0l,0l]
     sb = size(blu, /dim)
     if(NOT keyword_set(blu)) then sb = [0l,0l]
     
     xs = max([sr[0], sg[0], sb[0]])
     ys = max([sr[1], sg[1], sb[1]])

     if(xs EQ 0) then return, 0

     image = dblarr(xs, ys, 3)
     if(keyword_set(red)) then image[0:sr[0]-1,0:sr[1]-1,0] = red
     if(keyword_set(grn)) then image[0:sg[0]-1,0:sg[1]-1,1] = grn
     if(keyword_set(blu)) then image[0:sb[0]-1,0:sb[1]-1,2] = blu
    end

  end


 ctmod, top=top
 tvlct, r, g, b, /get

 return, image
end
;=============================================================================



;=============================================================================
; grim_display_image
;
;=============================================================================
pro grim_display_image, grim_data, data, plane=plane, $
       entire=entire, wnum=wnum, doffset=doffset, zoom=zoom, order=order, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, offset=offset, top=top, noplot=no_plot, $
       no_scale=no_scale, no_wset=no_wset, no_coord=no_coord, tvimage=tvimage, $
       min=min, max=max, home=home, draw_pixmap=draw_pixmap, current=current, no_copy=no_copy


 dim = nv_dim(plane.dd)

 ;-------------------------------
 ; set tvim coordinate system
 ;-------------------------------
 if(keyword_set(entire)) then $
  begin 
   wset, wnum
   entire_xsize = double(!d.x_size)
   entire_ysize = double(!d.y_size)
   wset, grim_data.wnum

   zoom = min([entire_xsize/dim[0], entire_ysize/dim[1]]) * 0.95

   offset = 0.5 * [dim[0]-entire_xsize/zoom, $
                     dim[1]-entire_ysize/zoom]
  end

 tvim, wnum, /silent, doffset=doffset, zoom=zoom, order=order, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, offset=offset, top=top, noplot=no_plot, $
       no_scale=no_scale, no_wset=no_wset, no_coord=no_coord, tvimage=tvimage, $
       min=min, max=max, home=home, draw_pixmap=draw_pixmap, no_copy=no_copy;, erase=erase



 ;---------------
 ; scale image
 ;---------------
; if(grim_data.type EQ 'render') then $
;  begin
;   ctmod, top=top
;   if(keyword_set(top)) then n_colors = top+1
;   colormap = compute_colormap(plane.cmd, n_colors=n_colors)
;   tvimage = grim_render_image(grim_data, plane=plane)
;   tvimage = apply_colormap(tvimage, colormap, max=plane.max, min=0)
;  end $
; else $
  begin
   tvimage = grim_scale_image(grim_data, data, r, g, b, current=current, $
                                      plane=plane, no_scale=no_scale, top=top)
   if(NOT keyword_set(tvimage)) then $
    begin
     erase
     return
    end

   *grim_data.tv_rp = r
   *grim_data.tv_gp = g
   *grim_data.tv_bp = b
   grim_set_data, grim_data, grim_data.base

   s = size(tvimage)
   image_xsize = s[1]
   image_ysize = s[2]


   if(((where(r-g NE 0))[0] NE -1) OR ((where(g-b NE 0))[0] NE -1)) then $
    begin
     _tvimage = dblarr(image_xsize, image_ysize, 3)
     _tvimage[*,*,0] = apply_colormap(tvimage, r)
     _tvimage[*,*,1] = apply_colormap(tvimage, g)
     _tvimage[*,*,2] = apply_colormap(tvimage, b)
     tvimage = _tvimage
     _tvimage = 0   
    end
  end 


 ;---------------------
 ; display image
 ;---------------------
 if(wnum EQ grim_data.wnum) then draw_pixmap = grim_data.redraw_pixmap

 tvim, tvimage, /tvimage, /silent, wnum, noplot=no_plot, $
     min=min, max=max, draw_pixmap=draw_pixmap, no_copy=no_copy, $
     no_scale=no_scale

 min = (max = 0)

 if(keyword_set(tvimage)) then $
  begin
   if(NOT defined(min)) then min = min(tvimage)
   if(NOT defined(max)) then max = max(tvimage)
  end

 *grim_data.min_p = min
 *grim_data.max_p = max


end
;=============================================================================



;=============================================================================
; grim_display_plot
;
;=============================================================================
pro grim_display_plot, grim_data, data, plane=plane, doffset=doffset, $
       wnum=wnum, xrange=xrange, yrange=yrange, no_wset=no_wset, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, position=position, dx=dx, dy=dy, $
       entire=entire, erase=erase, no_coord=no_coord, $
       color=color, nodraw=nodraw

;print, plane.xrange, plane.yrange

 if(NOT keyword_set(data)) then data = nv_data(plane.dd)

 ;---------------------------------------
 ; set view unless forced
 ;---------------------------------------
 if((NOT keyword_set(default)) $
     AND (NOT keyword_set(previous)) $
     AND (NOT keyword_set(flip)) $
     AND (NOT keyword_set(restore)) ) then $
  begin
   if(NOT keyword_set(xrange)) then $
    begin
     if((plane.yrange[0] NE 0) OR (plane.yrange[1] NE 0)) then $
      begin
       xrange = plane.xrange
       yrange = plane.yrange
       position = plane.position
      end $
     else $
      begin
       tvgr, grim_data.wnum, get=tvd
       if((tvd.xrange[0] NE 0) OR (tvd.xrange[1] NE 0)) then $
        begin
         xrange = tvd.xrange
yarr = data[1,*]
yrange = [min(yarr), max(yarr)]

;         yrange = tvd.yrange
         position = tvd.position
        end
      end
    end
  end


 xarr = data[0,*] & yarr = data[1,*]

 parm = plane.parm

 ;-----------------------------------------------------------------------
 ; if /entire, set ranges so that entire image is displayed
 ;-----------------------------------------------------------------------
 if(keyword_set(entire)) then $
  begin 
   xrange = [min(xarr), max(xarr)]
   yrange = [min(yarr), max(yarr)]
  end

 ;---------------------
 ; display plot
 ;---------------------
 if(NOT keyword_set(no_color)) then color = parm.color
;plot, xarr, yarr, xrange=xrange

 if(keyword_set(doffset)) then $
  begin
   dx = doffset[0]
   dy = doffset[1]
  end

 tvgr, wnum, xarr, yarr, xrange=xrange, yrange=yrange, no_wset=no_wset, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, position=position, dx=dx, dy=dy, $
       entire=entire, erase=erase, no_coord=no_coord, $
       xtitle=plane.xtitle, ytitle=plane.ytitle, $
       title=plane.title, thick=parm.thick, nsum=parm.nsum, color=color, $
       psym=parm.psym, symsize=parm.symsize;, nodraw=nodraw

 ;----------------------------
 ; save view
 ;----------------------------
 tvgr, grim_data.wnum, get=tvd
 plane.xrange = tvd.xrange
 plane.yrange = tvd.yrange

 ;-----------------------------------
 ; tie xranges of all planes
 ;-----------------------------------
 all_planes = grim_get_plane(grim_data, /all, pn=pn)
 nall = n_elements(all_planes)
 for i=0, nall-1 do if(pn[i] NE plane.pn) then $ 
  begin
   all_planes[i].xrange = plane.xrange
   grim_set_plane, grim_data, all_planes[i], pn=pn[i]
  end



 plane.position = tvd.position
 grim_set_plane, grim_data, plane, pn=plane.pn



end
;=============================================================================



;=============================================================================
; grim_display
;
;=============================================================================
pro grim_display, grim_data, data, plane=plane, wnum=wnum, home=home, $
       no_image=no_image, no_axes=no_axes, doffset=doffset, no_erase=no_erase, $
       zoom=zoom, order=order, xsize=xsize, ysize=ysize, offset=offset, $
       default=default, previous=previous, flip=flip, restore=restore,$
       use_pixmap=use_pixmap, pixmap_box_center=pixmap_box_center, no_copy=no_copy, $
       pixmap_box_side=pixmap_box_side, no_back=no_back, entire=entire, $
       no_wset=no_wset, no_coord=no_coord, tvimage=tvimage, no_plot=no_plot, $
       nodraw=nodraw, xrange=xrange, yrange=yrange, dx=dx, dy=dy, current=current, $
       pixmap_to_use=pixmap_to_use

 erase = 1
 if(keyword_set(no_erase)) then erase = 0
 no_scale = 1


 if(NOT keyword_set(pixmap_to_use)) then pixmap_to_use = grim_data.pixmap

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)
 if(NOT keyword_set(wnum)) then wnum = grim_data.wnum

 ;------------------------------------------------------
 ; if /use_pixmap then just copy from stored image
 ;------------------------------------------------------
 if(keyword_set(use_pixmap)) then $
  begin

   x0 = 0 & y0 = 0
   xsize = !d.x_size-1 
   ysize = !d.y_size-1

   if(keyword_set(pixmap_box_center)) then $
    begin 
     x0 = (pixmap_box_center[0] - pixmap_box_side/2) > 0
     y0 = (pixmap_box_center[1] - pixmap_box_side/2) > 0
     xsize = pixmap_box_side < $
                        abs(xsize - pixmap_box_center[0] + pixmap_box_side/2)
     ysize = pixmap_box_side < $
                        abs(ysize - pixmap_box_center[1] + pixmap_box_side/2)
    end

   wset, wnum
   if((x0 GE 0) AND (x0 LT !d.x_size) AND $
        (y0 GE 0) AND (y0 LT !d.y_size) AND $
        (xsize GT 0) AND (ysize GT 0)) then $
               device, copy=[x0,y0, xsize,ysize, x0,y0, pixmap_to_use]
  end $
 else $
  begin
   if(grim_data.type NE 'plot') then $
     grim_display_image, grim_data, data, plane=plane, no_copy=no_copy, $
       entire=entire, wnum=wnum, doffset=doffset, zoom=zoom, order=order, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, offset=offset, top=top, noplot=no_plot, $
       no_scale=no_scale, no_wset=no_wset, no_coord=no_coord, tvimage=tvimage, $
       min=min, max=max, home=home, draw_pixmap=draw_pixmap, current=current $

   else grim_display_plot, grim_data, data, plane=plane, doffset=doffset, $
       wnum=wnum, xrange=xrange, yrange=yrange, no_wset=no_wset, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, position=position, dx=dx, dy=dy, $
       entire=entire, erase=erase, no_coord=no_coord, color=color, nodraw=nodraw


   ;-------------------------------------
   ; copy to backing pixmap
   ;-------------------------------------
   if(NOT keyword_set(no_back)) then $
    begin
     wnum = !d.window
     wset, pixmap_to_use
     device, copy=[0,0, !d.x_size-1,!d.y_size-1, 0,0, wnum]
     wset, wnum
    end
  end

end
;=============================================================================



;=============================================================================
; grim_show_context_image
;
;=============================================================================
pro grim_show_context_image, grim_data

 wset, grim_data.context_wnum
 device, copy=[0,0, !d.x_size-1,!d.y_size-1, 0,0, grim_data.context_pixmap]
 wset, grim_data.wnum

end
;=============================================================================



;=============================================================================
; grim_show_axes
;
;  inertial axes:	blue
;  sun direction:	yellow
;  camera axes:		red
;  dir. to primary:	green
;
;  Axis source is just in front of the camera.
;
;=============================================================================
pro grim_show_axes, grim_data, plane
@grim_constants.common

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)
 widget_control, grim_data.axes_base, xoff=0, yoff=!d.y_size-AXES_SIZE

 ;---------------------------------
 ; clear axes window
 ;---------------------------------
 wnum = !d.window
 wset, grim_data.axes_wnum
 erase
 wset, wnum

 ;---------------------------------
 ; draw axis vectors
 ;---------------------------------
 if(NOT grim_test_map(grim_data)) then $
  if(grim_data.axes_flag) then $
   if(keyword_set(*plane.cd_p)) then $ 
    begin
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     ; compute source location
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     device_pt = [AXES_SIZE/2, AXES_SIZE/2]
     image_pt = (convert_coord(device_pt[0], device_pt[1], /device, /to_data))[0:1]

     cd = *plane.cd_p
     dir = image_to_inertial(cd, image_pt)
     source = bod_pos(cd) + dir*100000d 

     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     ; compute length in data units
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     device_len = AXES_SIZE/3
     device_corners = [tr([0,0]), tr([!d.x_size-1,0])]
     image_corners = (convert_coord(device_corners[0,*], device_corners[1,*], $
                                                    /device, /to_data))[0:1,*]
     len = device_len * p_mag(image_corners[*,0]-image_corners[*,1])/!d.x_size

     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     ; draw inertial axes
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     pg_draw_vector, cd=cd, source, (bod_orient(bod_inertial())), $
         plab=['x','y','z'], col='blue', len=len, draw_wnum=grim_data.axes_wnum, $
         label_shade=0.75

     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     ; draw camera axes
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     pg_draw_vector, cd=cd, source, (bod_orient(cd)), $
         plab=['cx','cy','cz'], col='red', len=len, draw_wnum=grim_data.axes_wnum, $
         label_shade=0.75

     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     ; draw sun vector
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     if(keyword_set(*plane.sund_p)) then $
       pg_draw_vector, cd=cd, source, /noshort, /fix, $
         v_unit(bod_pos(*plane.sund_p) - bod_pos(cd)), $
         plab=['SUN'], col='yellow', len=len, draw_wnum=grim_data.axes_wnum, $
         label_shade=0.75

     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     ; draw primary planet vector
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     if(keyword_set(*plane.pd_p)) then $
      begin
       pd = get_primary(cd, *plane.pd_p)
       pg_draw_vector, cd=cd, source, /noshort, /fix, $
         v_unit(bod_pos(pd) - bod_pos(cd)), $
         plab=cor_name(pd), col='green', len=len, draw_wnum=grim_data.axes_wnum, $
         label_shade=0.75
      end
    end

 ;----------------------------
 ; axes window outline
 ;----------------------------
 wset, grim_data.axes_wnum
 plots, /device, col=ctblue(), $
     [0,!d.x_size-1,!d.x_size-1,0,0], [0,0,!d.y_size-1,!d.y_size-1,0], th=4
 grim_wset, grim_data, grim_data.wnum

end
;=============================================================================



;=============================================================================
; grim_add_refresh_callback
;
;=============================================================================
pro grim_add_refresh_callback, callbacks, data_ps, top=top

 grim_data = grim_get_data(top)

 rf_callbacks = *grim_data.rf_callbacks_p
 rf_data_ps = *grim_data.rf_callbacks_data_pp

 grim_add_callback, callbacks, data_ps, rf_callbacks, rf_data_ps

 *grim_data.rf_callbacks_p = rf_callbacks
 *grim_data.rf_callbacks_data_pp = rf_data_ps

 grim_set_data, grim_data, grim_data.base
end
;=============================================================================



;=============================================================================
; grim_rm_refresh_callback
;
;=============================================================================
pro grim_rm_refresh_callback, data_ps, top=top

 grim_data = grim_get_data(top)
 if(NOT grim_exists(grim_data)) then return

 rf_callbacks = *grim_data.rf_callbacks_p
 rf_data_ps = *grim_data.rf_callbacks_data_pp

 grim_rm_callback, data_ps, rf_callbacks, rf_data_ps

 *grim_data.rf_callbacks_p = rf_callbacks
 *grim_data.rf_callbacks_data_pp = rf_data_ps

 grim_set_data, grim_data, grim_data.base
end
;=============================================================================



;=============================================================================
; grim_call_refresh_callbacks
;
;=============================================================================
pro grim_call_refresh_callbacks, grim_data

 grim_call_callbacks, *grim_data.rf_callbacks_p, *grim_data.rf_callbacks_data_pp

end
;=============================================================================



;=============================================================================
; grim_title
;
;=============================================================================
function grim_title, plane, primary=primary

 if(NOT keyword_set(plane)) then $
  begin
   grim_data = grim_get_data(primary=primary)
   plane = grim_get_plane(grim_data)
  end

 if(NOT keyword_set(plane.filename)) then name = nv_id_string(plane.dd) $
 else split_filename, plane.filename, dir, name

 return, name[0]
end
;=============================================================================



;=============================================================================
; grim_refresh
;
;=============================================================================
pro grim_refresh, grim_data, wnum=wnum, plane=plane, $
 no_image=no_image, no_objects=no_objects, no_axes=no_axes, $
 no_title=no_title, home=home, xrange=xrange, yrange=yrange, $
 doffset=doffset, no_erase=no_erase, zoom=zoom, order=order, $
 default=default, previous=previous, flip=flip, restore=restore, $
 xsize=xsize, ysize=ysize, offset=offset, use_pixmap=use_pixmap, $
 pixmap_box_center=pixmap_box_center, pixmap_box_side=pixmap_box_side, $
 context=context, entire=entire, noglass=noglass, no_wset=no_wset, $
 no_context=no_context, no_callback=no_callback, no_back=no_back, $
 no_coord=no_coord, tvimage=tvimage, no_plot=no_plot, just_image=just_image, $
 dx=dx, dy=dy, update=update, current=current, no_copy=no_copy, no_main=no_main
@grim_block.include

 
 if(NOT keyword_set(grim_data)) then grim_data = grim_get_data() 
 if(NOT keyword_set(noglass)) then widget_control, grim_data.draw, /hourglass

 grim_data.guideline_save_xy = [-1,-1]

 if(NOT keyword_set(plane)) then $
  begin
   plane = grim_get_plane(grim_data)
   planes = grim_get_visible_planes(grim_data)
  end $
 else planes = plane

 grim_update_shadows, grim_data, plane=plane

 ;-----------------------------------
 ; apply any default activations
 ;-----------------------------------
; grim_default_activations, grim_data, plane=plane

 ;-----------------------------------
 ; redraw main image
 ;-----------------------------------
 if(NOT keyword_set(no_image)) then $
  if(NOT keyword_set(no_main)) then $
   begin
    grim_display, grim_data, data, wnum=wnum, plane=plane, xrange=xrange, yrange=yrange, $
         no_axes=no_axes, doffset=doffset, no_wset=no_wset, no_back=no_back, $
         no_erase=no_erase, zoom=zoom, order=order, entire=entire, $
         default=default, previous=previous, flip=flip, restore=restore, $
         xsize=xsize, ysize=ysize, offset=offset, use_pixmap=use_pixmap, $
         pixmap_box_center=pixmap_box_center, pixmap_box_side=pixmap_box_side, $
         no_coord=no_coord, tvimage=tvimage, no_plot=no_plot, home=home, $
         dx=dx, dy=dy, current=current, no_copy=no_copy
   end


 if(grim_data.beta) then grim_set_render_button, grim_data


 ;-----------------------------------
 ; redraw context image
 ;-----------------------------------
 if(NOT keyword_set(no_context)) then $
  if(NOT keyword_set(no_image)) then $
   if(grim_data.context_mapped) then $
    begin
     tvim, grim_data.wnum, get=tvd, /no_coord

     grim_display, grim_data, data, wnum=grim_data.context_pixmap, plane=plane, $
;           use_pixmap=use_pixmap, pixmap_to_use=grim_data.context_pixmap, $
           /entire, order=tvd.order, nodraw=nodraw, /no_back

     grim_display, grim_data, data, wnum=grim_data.context_wnum, plane=plane, $
           /entire, order=tvd.order, /no_back, /no_image, /no_erase, nodraw=nodraw
     grim_wset, grim_data, grim_data.wnum
    end


 ;-----------------------------------
 ; redraw overlays
 ;-----------------------------------
 if(NOT keyword_set(no_objects)) then $
      grim_draw, grim_data, plane=planes, /all, update=update


 ;------------------------------------
 ; redisplay axes
 ;------------------------------------
 if(NOT keyword_set(no_axes)) then $
           grim_draw_axes, grim_data, data, plane=plane, no_context=no_context, $
                            no_wset=no_wset


 ;------------------------------------------
 ; copy context image to screen if mapped
 ;------------------------------------------
 if(NOT keyword_set(no_context)) then $
        if(grim_data.context_mapped) then grim_show_context_image, grim_data


 ;-----------------------------------
 ; set base title
 ;-----------------------------------
 if(NOT keyword_set(no_title)) then $
  begin
   beta = ''
   if(grim_data.beta) then beta = '(beta)'
   title = 'grim' + beta + ' ' + strtrim(grim_data.grnum,2) + $
           ';  plane ' + strtrim(grim_data.pn,2) + ' of ' + $
           strtrim(grim_data.n_planes,2) + ';  ' + grim_title(plane)

   widget_control, grim_data.base,  tlb_set_title = title
  end


 ;-----------------------------------
 ; clear out plane text box
 ;-----------------------------------
 widget_control, grim_data.jumpto_text, set_value=''


 ;-----------------------------------
 ; update menu item sensitivity
 ;-----------------------------------
 menu_ids = *grim_data.menu_ids_p
 menu_desc = *grim_data.menu_desc_p
 if(grim_test_map(grim_data, plane=plane)) then $
  begin
   ;- - - - - - - - - - - - - - - - - - - - -
   ; allowed menu items
   ;- - - - - - - - - - - - - - - - - - - - -
   md_items = *grim_data.map_items_p
   if(keyword_set(*plane.od_p)) then $
       md_items = append_array(md_items, *grim_data.od_map_items_p)

   mark = bytarr(n_elements(menu_ids))

   n = n_elements(md_items)
   for i=0, n-1 do $
    begin
     w = where(strpos(menu_desc, md_items[i]) NE -1)
     if(w[0] NE -1) then $
      begin
       widget_control, menu_ids[w[0]], sensitive=1
       mark[w[0]] = 1
      end
    end

   w = where(mark EQ 0)
   if(w[0] NE -1) then for i=0, n_elements(w)-1 do $
               widget_control, menu_ids[w[i]], sensitive=0
  end $
 else $
  begin
   n = n_elements(menu_ids)
   for i=0, n-1 do widget_control, menu_ids[i], sensitive=1
  end


 ;-----------------------------------
 ; update undo/redo sensitivity
 ;-----------------------------------
 nhist = nv_nhist(plane.dd)
 sens = nhist GT 1
 widget_control, grim_data.undo_button, sensitive=sens
 widget_control, grim_data.undo_menu_id, sensitive=sens
 widget_control, grim_data.redo_button, sensitive=sens
 widget_control, grim_data.redo_menu_id, sensitive=sens


 ;-----------------------------------
 ; update active and primary arrays
 ;-----------------------------------
 grim_update_activated, grim_data, plane=plane


 ;-----------------------------------
 ; cull descriptors
 ;-----------------------------------
; grim_cull_descriptors, grim_data


 ;-----------------------------------
 ; update header window
 ;-----------------------------------
 if(widget_info(grim_data.header_text, /valid)) then $
  begin
   widget_control, grim_data.header_text, set_value=nv_header(plane.dd)
   widget_control, grim_data.header_base, tlb_set_title=grim_title(plane)
  end


 ;-----------------------------------
 ; update notes window
 ;-----------------------------------
 if(widget_info(grim_data.notes_text, /valid)) then $
  begin
   widget_control, grim_data.notes_text, set_value=*plane.notes_p
   widget_control, grim_data.notes_base, tlb_set_title=grim_title(plane)
  end

 
 ;-----------------------------------
 ; update _all_tops list
 ;-----------------------------------
 w = -1
 if(keyword_set(_all_tops)) then w = where(_all_tops EQ grim_data.base)
 if(w[0] EQ -1) then _all_tops = append_array(_all_tops, grim_data.base)


 ;-----------------------------------
 ; contact refresh callbacks
 ;-----------------------------------
 if(NOT keyword_set(no_callback)) then $
  begin
   grim_call_refresh_callbacks, grim_data
   grim_call_primary_callbacks
  end

 grim_wset, grim_data, grim_data.wnum

; nv_flush
end
;=============================================================================



