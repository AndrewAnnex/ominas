;=============================================================================
; grim_set_overlay_update_flag
;
;=============================================================================
pro grim_set_overlay_update_flag, ps, value

 if(NOT keyword_set(ps)) then return

 nps = n_elements(ps)
 for i=0, nps-1 do $
   ps[i] = pgs_set_points(ps[i], uname='GRIM_UPDATE_FLAG', udata=value, /noev)

end
;=============================================================================



;=============================================================================
; grim_get_overlay_update_flag
;
;=============================================================================
function grim_get_overlay_update_flag, ps

 if(NOT keyword_set(ps)) then return, 0

 nps = n_elements(ps)
 vals = bytarr(nps)

 for i=0, nps-1 do $
  begin
   pgs_points, ps[i], uname='GRIM_UPDATE_FLAG', udata=value
   vals[i] = value
  end

 return, vals
end
;=============================================================================



;=============================================================================
; grim_get_updated_ps
;
;=============================================================================
function grim_get_updated_ps, _ps, ii=ii, clear=clear

 ii = 0

 ps = 0
 nps = n_elements(_ps)

 for i=0, nps-1 do $
  begin
   val = grim_get_overlay_update_flag(_ps[i])
   if(val[0] EQ 1) then $
    begin
     ps = append_array(ps, _ps[i])
     ii = append_array(ii, [i])
    end
  end


 if(keyword_set(clear)) then grim_set_overlay_update_flag, ps, 0


 if(NOT keyword__set(ii)) then ii = -1			; need keyword__set here!

 return, ps
end
;=============================================================================



;=============================================================================
; grim_get_xd
;
;=============================================================================
function grim_get_xd, grim_data, plane=plane, class, w=w, idps=idps

 if(class[0] EQ '') then return, ptr_new()

 if(class[0] EQ 'all') then class = ['planet', 'ring', 'sun', 'star', 'camera', 'station']

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 n = n_elements(class)

 xds = 0
 for i=0, n-1 do $
  case class[i] of
   'camera'	:	$
     begin
      xd = *plane.cd_p
      if(keyword_set(xd)) then $
       begin
        xds = append_array(xds, xd)
        idps = append_array(idps, nv_extract_idp(xd))
       end
     end
   'planet'	:	$
     begin
      xd = *plane.pd_p
      if(keyword_set(xd)) then $
       begin
        xds = append_array(xds, xd)
        idps = append_array(idps, nv_extract_idp(xd))
       end
     end
   'ring'	:	$
     begin
      xd = *plane.rd_p
      if(keyword_set(xd)) then $
       begin
        xds = append_array(xds, xd)
        idps = append_array(idps, nv_extract_idp(xd))
       end
     end
   'sun'	:	$
     begin
      xd = *plane.sund_p
      if(keyword_set(xd)) then $
       begin
        xds = append_array(xds, xd)
        idps = append_array(idps, nv_extract_idp(xd))
       end
     end
   'star'	:	$
     begin
      xd = *plane.sd_p
      if(keyword_set(xd)) then $
       begin
        xds = append_array(xds, xd)
        idps = append_array(idps, nv_extract_idp(xd))
       end
     end
   'station'	:	$
     begin
      xd = *plane.std_p
      if(keyword_set(xd)) then $
       begin
        xds = append_array(xds, xd)
        idps = append_array(idps, nv_extract_idp(xd))
       end
     end
  endcase

 if(defined(w)) then if(w[0] NE -1) then idps = idps[w]

 return, xds
end
;=============================================================================



;=============================================================================
; grim_get_overlay_psp
;
;=============================================================================
function grim_get_overlay_psp, grim_data, name, plane=plane, data=data, $
                              class=class, dep=dep, labels=labels, ii=ii, $
                              color=color, psym=psym, tlab=tlab, tshade=tshade, symsize=symsize, $
                              shade=shade, tfill=tfill

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 if(keyword_set(name)) then $
         if(name EQ 'all') then return, *plane.overlay_psps

 if(NOT defined(ii)) then $
  begin
   if(keyword_set(name)) then ii = (where(*plane.overlay_names_p EQ name))[0] $
   else if(keyword_set(class)) then ii = (where(*plane.overlay_classes_p EQ class))[0]
  end
 if(ii[0] EQ -1) then return, 0

 name = (*plane.overlay_names_p)[ii]
 class = (*plane.overlay_classes_p)[ii]
 
 dep = *(*plane.overlay_dep_p)[ii]

 if(keyword_set((*plane.overlay_labels_p)[ii])) then $
                                  labels = *(*plane.overlay_labels_p)[ii]


 color = (*plane.overlay_color_p)[ii]
 psym = (*plane.overlay_psym_p)[ii]
 symsize = (*plane.overlay_symsize_p)[ii]
 shade = (*plane.overlay_shade_p)[ii]
 tlab = (*plane.overlay_tlab_p)[ii]
 tshade = (*plane.overlay_tshade_p)[ii]
 tfill = (*plane.overlay_tfill_p)[ii]

 data_p = (*plane.overlay_data_p)[ii]
 if(ptr_valid(data_p)) then data = *data_p

 return, (*plane.overlay_psps)[ii]
end
;=============================================================================



;=============================================================================
; grim_get_active_overlays
;
;=============================================================================
function grim_get_active_overlays, grim_data, plane=plane, type, $
     active_indices=active_indices, inactive_indices=inactive_indices

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 active_indices = (inactive_indices = -1)

 ;-------------------------------------------
 ; determine which arrays to use
 ;-------------------------------------------
 ps = *(grim_get_overlay_psp(grim_data, plane=plane, type))
 nps = n_elements(ps)
 if(NOT keyword_set(ps)) then return, 0

 ;--------------------------------------
 ; find requested active overlay arrays
 ;--------------------------------------
 _inactive_indices = lindgen(nps)
 active_ps = 0

 if(keyword_set(*plane.active_overlays_psp)) then $
  begin
   n_active = n_elements(*plane.active_overlays_psp)
   w = make_array(n_active, val=-1l)
   for i=0, n_active-1 do $
    begin
     pgs_points_ps, (*plane.active_overlays_psp)[i], p=p
     pgs_points_ps, ps, p=pp
     if((where(pp EQ p))[0] NE -1) then w[i] = i 
    end

   ww = where(w NE -1)
   if(ww[0] NE -1) then $
    begin 
     w = w[ww]

     active_ps = (*plane.active_overlays_psp)[w]

     ;-------------------------------------------
     ; compute indices
     ;-------------------------------------------
     pgs_points_ps, active_ps, p=active_p
     pgs_points_ps, ps, p=p
  
     _active_indices = nwhere(p, active_p)
     _inactive_indices = complement(ps, _active_indices)
    end 
  end

 ;-----------------------------------------
 ; remove undefined overlays
 ;-----------------------------------------
 pgs_points_ps, ps, desc=desc
 www = where(desc NE '') 

 if(www[0] EQ -1) then return, 0

 if(n_elements(_active_indices) GT 0) then active_indices = _active_indices
 if(n_elements(_inactive_indices) GT 0) then $
                                         inactive_indices = _inactive_indices

 w = n_where(www, active_indices)
 if(w[0] NE -1) then $
  begin
   active_indices = active_indices[w]
   active_ps = active_ps[w]
  end

 w = n_where(www, inactive_indices)
 if(w[0] NE -1) then inactive_indices = inactive_indices[w]

; if((active_indices[0] EQ -1) AND (inactive_indices[0] EQ -1)) then $
;  inactive_indices = lindgen()

 return, active_ps
end
;=============================================================================



;=============================================================================
; grim_get_all_active_overlays
;
;=============================================================================
function grim_get_all_active_overlays, grim_data, plane=plane, names=names

 if(NOT keyword_set(names)) then $
   names = ['planet_center', $
            'limb', $
            'terminator', $
            'ring', $
            'star', $
            'station', $
            'planet_grid', $
            'ring_grid']

 for i=0, n_elements(names)-1 do $
  ps = append_array(ps, grim_get_active_overlays(grim_data, plane=plane, names[i]))

 return, ps
end
;=============================================================================



;=============================================================================
; grim_get_all_overlays
;
;=============================================================================
function grim_get_all_overlays, grim_data, plane=plane, names=names

 if(NOT keyword_set(names)) then $
   names = ['planet_center', $
            'limb', $
            'terminator', $
            'ring', $
            'star', $
            'station', $
            'planet_grid', $
            'ring_grid']

 for i=0, n_elements(names)-1 do $
  ps = append_array(ps, *(grim_get_overlay_psp(grim_data, plane=plane, names[i])))

 return, ps
end
;=============================================================================



;=============================================================================
; grim_get_active_xds
;
;=============================================================================
function grim_get_active_xds, plane, class, $
     active_indices=active_indices, inactive_indices=inactive_indices

 active_indices = -1

 ;-------------------------------------------
 ; determine which arrays to use
 ;-------------------------------------------
 if(NOT keyword_set(class)) then return, *plane.active_xd_p

 case (class) of
  'planet' :  xd_p = plane.pd_p
  'ring' :  xd_p = plane.rd_p
  'star' :  xd_p = plane.sd_p
  'station' :  xd_p = plane.std_p
 endcase

 if(NOT keyword_set(*xd_p)) then return, 0

 ;------------------------------
 ; get the descriptors
 ;------------------------------
 inactive_indices = lindgen(n_elements(*xd_p))

 if(NOT keyword_set(*plane.active_xd_p)) then return, 0

 n_active = n_elements(*plane.active_xd_p)
 w = make_array(n_active, val=-1l)
 for i=0, n_active-1 do $
           if(class_get((*plane.active_xd_p)[i]) EQ strupcase(class)) then w[i] = i

 ww = where(w NE -1)
 if(ww[0] EQ -1) then return, 0 
 w = w[ww]

 active_xds = (*plane.active_xd_p)[w]

 ;-------------------------------------------
 ; get the corresponding points arrays
 ;-------------------------------------------
 active_indices = nwhere(get_core_name(*xd_p), get_core_name(active_xds))
 inactive_indices = complement(*xd_p, active_indices)

 return, active_xds
end
;=============================================================================



;=============================================================================
; grim_update_activated
;
;=============================================================================
pro grim_update_activated, grim_data, plane=plane

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 ;- - - - - - - - - - - - - - - - - - - - - - - - -
 ; verify that all active arrays actually exist
 ;- - - - - - - - - - - - - - - - - - - - - - - - -
 active_ps = *plane.active_overlays_psp
 if(keyword_set(active_ps)) then $
  begin
   pgs_points_ps, active_ps, p=active_p

   if(keyword_set(active_p)) then $
    begin
     psps = grim_get_overlay_psp(grim_data, plane=plane, 'all')
     npsps = n_elements(psps)

     n_active = n_elements(active_p)
     mark = make_array(n_active, val=1b)

     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     ; compare each active overlay to every existing overlay point.
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
     for i=0, n_active-1 do $
      begin
       for j=0, npsps-1 do $
        begin
         ps = *psps[j]
         if(keyword_set(ps)) then $
          begin
           pgs_points_ps, *psps[j], p=p
           w = where(p EQ active_p[i])
           if(w[0] NE -1) then mark[i] = 0
          end
        end
      end

     w = where(mark EQ 1)
     if(w[0] NE -1) then $
        *plane.active_overlays_psp = $
                  rm_list_item(*plane.active_overlays_psp, w, only=0)    
     if(NOT keyword_set((*plane.active_overlays_psp)[0])) then $
                                           *plane.active_overlays_psp = 0
    end
  end


 ;- - - - - - - - - - - - - - - - - - - - - - - - -
 ; update activations for each descriptor type
 ;- - - - - - - - - - - - - - - - - - - - - - - - -
 ss = sort(*plane.active_xd_p)
 *plane.active_xd_p = (*plane.active_xd_p)[ss]
 uu = uniq(*plane.active_xd_p)
 *plane.active_xd_p = (*plane.active_xd_p)[uu]

 grim_deactivate_xd, plane, *plane.pd_p
 grim_deactivate_xd, plane, *plane.rd_p
 grim_deactivate_xd, plane, *plane.sd_p
 grim_deactivate_xd, plane, *plane.std_p
 
 names = *plane.overlay_names_p
 for i=0, n_elements(names)-1 do $
  begin
   name = names[i]
   class = ''
   psp = grim_get_overlay_psp(grim_data, plane=plane, name, class=class) 

   xd = grim_get_xd(grim_data, plane=plane, class)
   if(keyword_set(xd)) then $
    begin
     active_ps = grim_get_active_overlays(grim_data, plane=plane, name, active=active)

     ps = *psp
     nps = n_elements(ps)/n_elements(xd)

     if(active[0] NE -1) then grim_activate_xd, plane, xd[active/nps] 
    end
  end 

 ss = sort(*plane.active_xd_p)
 *plane.active_xd_p = (*plane.active_xd_p)[ss]
 uu = uniq(*plane.active_xd_p)
 *plane.active_xd_p = (*plane.active_xd_p)[uu]
end
;=============================================================================



;=============================================================================
; grim_fill
;
;=============================================================================
pro grim_fill, ps, name, color

 shade = call_function('grim_shade_'+ name, data, ps)
 col = make_array(n_elements(shade), val=color)
 nps = n_elements(ps)
 for j=0, nps-1 do $
  begin
   pgs_visible_points, ps[j], p=p

   if(keyword_set(p)) then $
    begin
;     device, set_graphics=1
     polyfill, p[0,*], p[1,*], col=call_function('ct' + col[j], shade[j])
     device, set_graphics=3
    end
  end


end
;=============================================================================



;=============================================================================
; grim_draw
;
;=============================================================================
pro grim_draw, grim_data, planes=planes, $
       all=all, wnum=wnum, $
       user=user, tiepoints=tiepoints, $
       label=labels, readout=readout, measure=measure, update=update, $
       nopoints=nopoints

 if(grim_data.hidden) then return

 if(keyword_set(wnum)) then grim_wset, grim_data, wnum

 if(NOT keyword_set(planes)) then planes = grim_get_plane(grim_data)

 nplanes = n_elements(planes)
 for jj=0, nplanes-1 do $
  begin
   plane = planes[jj]

   inactive_color = 'cyan'
   hidden = 'hidden'

   if(keyword_set(all)) then $
    begin
     user=1 & tiepoints=1 & mlab = 1 & readout = 1 & measure = 1
    end

   if(grim_test_map(grim_data)) then mlab = 0


  ;--------------------------------
  ; overlay points
  ;--------------------------------
  if(NOT keyword_set(nopoints)) then $
   begin
    names = *plane.overlay_names_p
    for i=0, n_elements(names)-1 do $
     begin
      name = names[i]
     psp = grim_get_overlay_psp(grim_data, plane=plane, name, data=data, $
             color=color, psym=psym, symsize=symsize, shade=shade, tlab=tlab, $
             tshade=tshade, tfill=tfill, labels=labels)
      if(color NE hidden) then $
       if(ptr_valid(psp)) then $
        if(keyword_set(*psp)) then $
         begin
          if(keyword_set(plane.override_color) $
                  AND (strupcase(plane.override_color) NE 'NONE')) then $
                                                   color = plane.override_color

          active_ps = grim_get_active_overlays(grim_data, plane=plane, name, $
                                 active_indices=active, inactive_indices=inactive)

          plabels = make_array(n_elements(*psp), val='')
          if(keyword_set(mlab) AND tlab) then plabels = labels

          if(symsize EQ 0) then $
           begin
            _symsize = call_function('grim_symsize_'+ name, data)
            if(_symsize[0] NE -1) then symsize = _symsize $
            else symsize = 1
           end


          ;- - - - - - - - - - - - - - - - - - - - - - -
          ; determine which overlays to actually draw
          ;- - - - - - - - - - - - - - - - - - - - - - -
          active_ps = 0 & active_plabels = 0
          if(active[0] NE -1) then $
           begin
            active_ps = (*psp)[active]
            active_plabels = plabels[active]
           end
          if(keyword_set(update)) then $
           begin
            active_ps = grim_get_updated_ps(active_ps, ii=ii, /clear)
            if(keyword_set(active_ps)) then active_plabels = active_plabels[ii]
           end

          inactive_ps = 0 & inactive_plabels = 0
          if(inactive[0] NE -1) then $
           begin
            inactive_ps = (*psp)[inactive]
            inactive_plabels = plabels[inactive]
           end
          if(keyword_set(update)) then $
           begin
            inactive_ps = grim_get_updated_ps(inactive_ps, ii=ii, /clear)
            if(keyword_set(inactive_ps)) then inactive_plabels = inactive_plabels[ii]
           end


          ;- - - - - - - - - - - - - - -
          ; fills
          ;- - - - - - - - - - - - - - -
          if(tfill) then $
           begin
            if(keyword_set(inactive_ps)) then grim_fill, inactive_ps, name, inactive_color
            if(keyword_set(active_ps)) then grim_fill, active_ps, name, color
           end $

          ;- - - - - - - - - - - - - - -
          ; points
          ;- - - - - - - - - - - - - - -
          else $
           begin
            ;- - - - - - - - - - - - - - -
            ; inactive points
            ;- - - - - - - - - - - - - - -
            if(keyword_set(inactive_ps)) then $
             begin
              if(NOT tshade) then shade = 1.0 $
              else shade = call_function('grim_shade_'+ name, data, inactive_ps)
              col = make_array(n_elements(shade), val=inactive_color)

              pg_draw, inactive_ps, col=col, shade=shade, label_shade=0.75, $
                             psym=psym, psize=symsize, plabels=inactive_plabels
             end
 
            ;- - - - - - - - - - - - - - -
            ; active points
            ;- - - - - - - - - - - - - - -
            if(keyword_set(active_ps)) then $
             begin
              if(NOT tshade) then shade = 1.0 $
              else shade = call_function('grim_shade_'+ name, data, active_ps)
              col = make_array(n_elements(shade), val=color)

              pg_draw, active_ps, col=col, shade=shade, label_shade=0.75, $
                             psym=psym, psize=symsize, plabels=active_plabels
             end
           end
         end
     end
   end


   ;--------------------------------
   ; user points
   ;--------------------------------
   if(keyword_set(user)) then $
    if(keyword_set(plane.user_ps_tlp)) then $
     begin
      grim_get_active_user_overlays, plane, $
                           active_tags=active_tags, inactive_tags=inactive_tags
      if(keyword_set(active_tags)) then $
       begin
        user_ps = grim_get_user_ps(plane=plane, active_tags) 
        n = n_elements(active_tags)
        for i=0, n-1 do $
         begin
          user_ps = $
            grim_get_user_ps(plane=plane, active_tags[i], $
                       color=user_color, psym=user_psym, symsize=user_symsize) 
          if(user_color[0] NE hidden) then $
            pg_draw, user_ps, col=user_color, psym=user_psym, psize=user_symsize
         end
       end

      if(keyword_set(inactive_tags)) then $
       begin
        user_ps = grim_get_user_ps(plane=plane, inactive_tags) 
        n = n_elements(inactive_tags)
        for i=0, n-1 do $
         begin
          user_ps = $
            grim_get_user_ps(plane=plane, inactive_tags[i], $
                       color=user_color, psym=user_psym, symsize=user_symsize) 
          if(user_color[0] NE hidden) then $
                  pg_draw, user_ps, col=inactive_color, psym=user_psym, psize=user_symsize
         end
       end
     end


   ;--------------------------------
   ; tiepoints
   ;--------------------------------
   if(keyword_set(tiepoints)) then $
    begin
     pgs_points, plane.tiepoints_ps, p=tp, flags=flags
     if(keyword__set(flags)) then $			; keyword__set intentional
      begin
       n = n_elements(flags)
       w = where(flags EQ 0)
       if(w[0] NE -1) then $
        begin
         p = tp[*,w]
         plots, p, psym=1, col=ctred()
         q = convert_coord(p[0,*], p[1,*], /data, /to_device)
         xyouts, /device, q[0,*]+4, q[1,*]+4, $
                                 strtrim((lindgen(n))[w],2), align=0.5
        end
      end
    end

  end


 ;--------------------------------
 ; readout mark
 ;--------------------------------
 if(keyword_set(readout)) then $
            plots, grim_data.readout_mark, psym=7, col=ctred()


 ;--------------------------------
 ; measure mark
 ;--------------------------------
 if(keyword_set(measure)) then $
            plots, grim_data.measure_mark, psym=-4, symsize=0.5, col=ctred()


 if(keyword_set(wnum)) then grim_wset, grim_data, grim_data.wnum

end
;=============================================================================



;=============================================================================
; grim_draw_axes
;
;=============================================================================
pro grim_draw_axes, grim_data, data, plane=plane, $
                    no_context=no_context, no_wset=no_wset
@grim_block.include

 if(grim_data.type NE 'plot') then $
  begin
;   mg = 0.03
;   plot, [0], [0], /noerase, /data, pos=[mg,mg, 1.0-mg,1.0-mg]

   ;----------------------------
   ; RA/DEC grid
   ;----------------------------
   if(grim_data.grid_flag) then $
      if(keyword_set(*plane.cd_p)) then $
               plots, radec_grid(*plane.cd_p), psym=3, col=ctblue()

   ;----------------------------
   ; pixel grid
   ;----------------------------
   if(grim_data.pixel_grid_flag) then $
               plots, pixel_grid(wnum=grim_data.wnum), psym=3, col=ctpurple()

   ;----------------------------
   ; main window image outline
   ;----------------------------
   dim = nv_dim(plane.dd)
   xsize = dim[0]
   ysize = dim[1]

   plots, [-0.5,xsize-0.5,xsize-0.5,-0.5,-0.5], $
          [-0.5,-0.5,ysize-0.5,ysize-0.5,-0.5], line=1


   ;----------------------------
   ; current plane outline
   ;----------------------------
   if(grim_data.highlight) then $
    begin
     image = nv_data(plane.dd);, sample=*grim_data.vpp)

     outline_pts = image_outline(image)
     plots, outline_pts, psym=3, col=ctyellow()

     if(NOT keyword_set(no_context)) then $
      if(grim_data.context_mapped) then $
       begin
        grim_wset, grim_data, grim_data.context_pixmap
        plots, outline_pts, psym=3, col=ctyellow()
        grim_wset, grim_data, grim_data.wnum
       end
 
    end

   ;----------------------------------------------------------------------
   ; axes
   ;----------------------------------------------------------------------
   grim_show_axes, grim_data, plane
  end   




 ;-----------------------------------------------
 ; primary window indicator outline
 ;-----------------------------------------------
 color = 0
 if(NOT widget_info(_primary, /valid)) then _primary = grim_data.base
 if(grim_data.base EQ _primary) then color = ctred() 
 if(NOT keyword__set(no_wset)) then grim_wset, grim_data, grim_data.wnum
 plots, [0,!d.x_size-1,!d.x_size-1,0,0], [0,0,!d.y_size-1,!d.y_size-1,0], $
           th=5, /device, color=color


 ;-----------------------------------------------
 ; FOV outline
 ;-----------------------------------------------



 ;----------------------------
 ; context window outline
 ;----------------------------
 if(NOT keyword_set(no_context)) then $
  if(grim_data.context_mapped) then $
   begin
    grim_wset, grim_data, grim_data.context_pixmap
    plots, /device, col=ctblue(), $
      [0,!d.x_size-1,!d.x_size-1,0,0], [0,0,!d.y_size-1,!d.y_size-1,0], th=4
    grim_wset, grim_data, grim_data.wnum


    ;-----------------------------------------------
    ; visible region outline in context window
    ;-----------------------------------------------
    p = tr([tr([0,0]),tr([!d.x_size, !d.y_size])])
    q = convert_coord(p, /device, /to_data)
    x0 = q[0,0]
    x1 = q[0,1]
    y0 = q[1,0]
    y1 = q[1,1]

    grim_wset, grim_data, grim_data.context_pixmap
    plots, /data, col=ctred(), [x0,x1,x1,x0,x0], [y0,y0,y1,y1,y0]
    grim_wset, grim_data, grim_data.wnum
   end

 
end
;=============================================================================



;=============================================================================
; grim_cat_points
;
;=============================================================================
function grim_cat_points, grim_data, all=all, active=active, plane=plane

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 ps = [{pg_points_struct}]


 ;------------------------------------
 ; only active points
 ;------------------------------------
 if(keyword_set(active)) then $
  begin
   if(keyword_set(*plane.active_overlays_psp)) then $
                         ps = append_array(ps, *plane.active_overlays_psp)

  end $
 ;------------------------------------
 ; all points
 ;------------------------------------
 else $
  begin
   psps = grim_get_overlay_psp(grim_data, plane=plane, 'all')
   if(keyword_set(psps)) then $
    begin
     n = n_elements(psps)
     for i=0, n-1 do ps = append_array(ps, decrapify((*psps[i])[*]))
    end

   user_ps = grim_get_user_ps(plane=plane)
   if(keyword_set(user_ps)) then ps = append_array(ps, user_ps)
  end


 if(n_elements(ps) EQ 1) then return, 0

 return, ps[1:*]
end
;=============================================================================



;=============================================================================
; grim_update_shadows
;
;=============================================================================
pro grim_update_shadows, grim_data, plane=_plane

return
 if(NOT keyword_set(_plane)) then plane = grim_get_plane(grim_data) $
 else plane = _plane

 ps = grim_cat_points(grim_data, plane=plane)
 if(NOT keyword_set(ps)) then return
 idp = nv_extract_idp(ps)
; xd = grim_get_xd(grim_data, plane=plane, 'all')
; if(NOT keyword_set(xd)) then return
; idp = nv_extract_idp(xd) ; can't do this because xd not all the same type

 shadow_ps = *(grim_get_overlay_psp(grim_data, plane=plane, 'shadow'))
 if(NOT keyword_set(shadow_ps)) then return

 n = n_elements(shadow_ps)
 mark = bytarr(n)

 for i=0, n-1 do $
  begin
   pgs_points, shadow_ps[i], uname='grim_dep', udata=dp
   if(NOT keyword_set(dp)) then mark[i] = 1 $
   else $
    begin
     dep = dp[n_elements(dp)-1]
     w = where(idp EQ dep)
     if(w[0] EQ -1) then mark[i] = 1
    end
  end

 ii = where(mark EQ 1)
 if(ii[0] NE -1) then shadow_ps = rm_list_item(shadow_ps, ii, only=0)

 if(NOT keyword_set(shadow_ps[0])) then shadow_ps = shadow_ps[0]
 *(grim_get_overlay_psp(grim_data, plane=plane, 'shadow')) = shadow_ps

end
;=============================================================================



;=============================================================================
; grim_rm_points
;
;=============================================================================
pro grim_rm_points, plane, psp, ii


 if(NOT ptr_valid(psp)) then retuan
 ps = (*psp)[ii]
 if(NOT pgs_valid(ps)) then return

 nv_notify_unregister, ps, 'grim_descriptor_notify'
; deactivate?
; for i=0, n_elements(ps)-1 do nv_free, ps[i]

 (*psp)[ii] = pgs_null()

end
;=============================================================================



;=============================================================================
; grim_add_points
;
;=============================================================================
pro grim_add_points, grim_data, object_ps, plane=plane, $
         idp_all=_idp_all, idp_each=idp_each, $
         name=name, replace=replace, overwrite=overwrite, $
         idp_cam=idp_cam, select=select, data=data

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 if(keyword_set(_idp_all)) then $
  begin
   select = where(_idp_all NE ptr_new())
   if(select[0] NE -1) then idp_all = _idp_all[select]
  end

 selected = 0
 if(n_elements(select) NE 0) then if(select[0] NE -1) then selected = 1

 ;--------------------------------------------------------------------
 ; determine dependencies and which points array to use
 ;
 ;  Each points array will depend on all the descriptors given
 ;  in idp_all.  Each points array for a given xd will also depend on 
 ;  descriptor whose idp is given in the corresponding position in
 ;  idp_each.
 ;
 ;--------------------------------------------------------------------
 psp = grim_get_overlay_psp(grim_data, name, plane=plane, $
                                       class=class, dep=dep, ii=ii)

 if(keyword_set(class)) then $
        xd = grim_get_xd(grim_data, plane=plane, class, idp=idp_each) $
 else if(keyword_set(idp_each)) then $
  begin
   dep_xds = grim_get_xd(grim_data, plane=plane, 'all')
   gd = pgs_idp_to_gd(idp_each, dep_xds)
   xd = gd.pd
  end

 if(NOT keyword_set(idp_all)) then $
  begin
   xds_all = grim_get_xd(grim_data, plane=plane, dep, idps=idps)
   idp_all = [idp_cam]
   if(keyword_set(idps)) then idp_all = [idp_all, idps]
  end

 if(keyword_set(idp_each)) then $
                     if(selected) then idp_each = idp_each[select]
; if(keyword_set(xd)) then *(*plane.overlay_labels_p)[ii] = cor_name(xd)
 if(keyword_set(data)) then *(*plane.overlay_data_p)[ii] = data


 ;--------------------------------------
 ; overlay array is nps x nd
 ;--------------------------------------

 ;- - - - - - - - - - - - - - - - - - - - - - - -
 ; determine nd for overlay array
 ;- - - - - - - - - - - - - - - - - - - - - - - -
 nd = 1
 if(keyword_set(xd)) then nd = n_elements(xd)

 ;- - - - - - - - - - - - - - - - - - - - - - - - - - - -
 ; nn is the number of objects actually being added
 ;- - - - - - - - - - - - - - - - - - - - - - - - - - - -
 if(selected) then nn = n_elements(select) $
 else nn = nd

 ;- - - - - - - - - - - - - - - - - - - - - - - -
 ; determine nps for overlay array
 ;- - - - - - - - - - - - - - - - - - - - - - - -
 nps = n_elements(object_ps)/nn

 ;- - - - - - - - - - - - - - - - - - - - - - - -
 ; save labels
 ;- - - - - - - - - - - - - - - - - - - - - - - -
 if(keyword_set(xd)) then $
          *(*plane.overlay_labels_p)[ii] = $
                 (cor_name(xd))[lindgen(nd)##make_array(nps,val=1d)]

 ;- - - - - - - - - - - - - - - - - - - - - - - -
 ; resize overlay array
 ;- - - - - - - - - - - - - - - - - - - - - - - -
 object_ps = reform(object_ps, nps, nn)



 ;--------------------------------------
 ; add the dependencies lists
 ;--------------------------------------
 _idp = [ptr_new()]
 if(keyword_set(idp_all)) then _idp = [idp_all]
 for i=0, nn-1 do $
  begin
   idp = [_idp]
   if(keyword_set(idp_each)) then idp = [_idp, (idp_each[i,*])[*]]
   for j=0, nps-1 do $
    begin
     if(pgs_valid(object_ps[j,i])) then $
      begin
       object_ps[j,i] = pgs_set_points(object_ps[j,i], uname='grim_dep', udata=idp, /noev)
       object_ps[j,i] = pgs_set_points(object_ps[j,i], uname='grim_name', udata=name, /noev)
      end
    end
  end


 ;--------------------------------------
 ; update the points arrays
 ;--------------------------------------
 if(NOT keyword_set(*psp)) then overwrite = 1 $
 else if(nps NE (size(*psp))[1]) then overwrite = 1

 if(keyword_set(overwrite)) then $
  begin
   *psp = object_ps
   if(selected) then $
    begin
     *psp = make_array(nps, nd, val={pg_points_struct})
     (*psp)[*,select] = object_ps
    end
  end $
 else if(keyword_set(replace)) then $
  begin
   if(selected) then $
    begin
     (*psp)[*,select] = object_ps
    end $
   else *psp = object_ps
  end $
 else *psp = [*psp, object_ps]	; this may not work right because of the dimensions


 ;--------------------------------------------------
 ; register for events on the points arrays
 ;--------------------------------------------------
; for i=0, nn-1 do $
;  for j=0, nps-1 do $
;   begin
;    nv_notify_register, object_ps[j,i], 'grim_descriptor_notify', $
;                                                   scalar_data=grim_data.base
;   end


end
;=============================================================================



;=============================================================================
; grim_default_activations
;
;=============================================================================
pro grim_default_activations, grim_data, plane=plane

 if(NOT keyword__set(plane)) then plane = grim_get_plane(grim_data)

 ;--------------------------------------------------------------------------
 ; if there's only one of a type of object, then it is automatically active
 ;--------------------------------------------------------------------------
; if(keyword__set(*plane.pd_p)) then $
;   if(n_elements(*plane.pd_p) EQ 1) then grim_activate, plane, *plane.pd_p

; if(keyword__set(*plane.rd_p)) then $
;   if(n_elements(*plane.rd_p) EQ 1) then grim_activate, plane, *plane.rd_p

; if(keyword__set(*plane.sd_p)) then $
;   if(n_elements(*plane.sd_p) EQ 1) then grim_activate, plane, *plane.sd_p


end
;=============================================================================



;=============================================================================
; grim_clear_overlay_points
;
;=============================================================================
pro grim_clear_overlay_points, psp, active_psp
@pgs_include.pro

 if(NOT keyword_set(*active_psp)) then return
 if(NOT keyword_set(*psp)) then return

 n_active = n_elements(*active_psp)

 for i=0, n_active-1 do $
  begin
   pgs_points_ps, *psp, p=p
   pgs_points_ps, (*active_psp)[i], p=active_p
 
   w = where(p EQ active_p)
   if(w[0] NE -1) then grim_rm_points, plane, psp, w[0]

;;   if(w[0] NE -1) then *psp = rm_list_item(*psp, w[0], only=0)
;;   if(NOT keyword_set(*psp[0])) then *psp = 0
  end

end
;=============================================================================



;=============================================================================
; grim_clear_active_overlays
;
;=============================================================================
pro grim_clear_active_overlays, plane

 ;------------------------------------------
 ; make active overlay points invisible
 ;------------------------------------------
 names = *plane.overlay_names_p
 for i=0, n_elements(names)-1 do $
  grim_clear_overlay_points, $
     grim_get_overlay_psp(grim_data, plane=plane, names[i]), $
                                                  plane.active_overlays_psp

 ;------------------------------------------
 ; clear active overlay arrays
 ;------------------------------------------
 *plane.active_overlays_psp = 0


end
;=============================================================================



;=============================================================================
; grim_frame_overlays
;
;=============================================================================
pro grim_frame_overlays, grim_data, plane, ps, slop=slop, xy=xy

 if(NOT keyword_set(slop)) then slop = 0.1
 
 ;--------------------------------
 ; compute corners
 ;--------------------------------
 pp = pg_points(ps)
 npp = n_elements(pp)/2

 xmin = min(pp[0,*])
 xmax = max(pp[0,*])
 ymin = min(pp[1,*])
 ymax = max(pp[1,*])

 dx = xmax - xmin
 dy = ymax - ymin

 xslop = dx*slop
 yslop = dy*slop

 xmin = xmin - xslop
 xmax = xmax + xslop
 ymin = ymin - yslop
 ymax = ymax + yslop


 ;--------------------------------
 ; compute new tvim params
 ;--------------------------------
 offset = [xmin, ymin]

 if(keyword_set(xy)) then $
      zoom = [!d.x_size/abs(xmin-xmax), !d.y_size/abs(ymin-ymax)] $
 else zoom = !d.x_size/abs(xmin-xmax) < !d.y_size/abs(ymin-ymax)

 tvim, offset=offset, zoom=zoom, /inherit, /silent

 cx = !d.x_size/2
 cy = !d.y_size/2
 q = convert_coord(cx, cy, /device, /to_data)
 p = 0.5d*[xmin+xmax, ymin+ymax]
 tvim, doffset=(p-q)[0:1], /inherit, /silent


end
;=============================================================================



;=============================================================================
; grim_hide_overlays
;
;=============================================================================
pro grim_hide_overlays, grim_data

 if(grim_data.hidden) then $
  begin
   grim_data.hidden = 0
   widget_control, grim_data.hide_button, set_value=grim_hide_bitmap()
  end $
 else $
  begin
   grim_data.hidden = 1
   widget_control, grim_data.hide_button, set_value=grim_unhide_bitmap()
  end

 grim_set_data, grim_data, grim_data.base
 grim_refresh, grim_data, /use_pixmap, /noglass

end
;=============================================================================



;=============================================================================
; grim_clear_objects
;
;=============================================================================
pro grim_clear_objects, grim_data, all=all, $
     cd=cd, pd=pd, rd=rd, sd=sd, std=std, sund=sund, planes=planes

 if(NOT keyword_set(planes)) then planes = grim_get_plane(grim_data)
 n = n_elements(planes)

 for i=0, n-1 do $
  begin
   ;----------------------------------
   ; clear descriptors
   ;----------------------------------
   if((keyword_set(all)) OR (keyword_set(cd))) then $
     grim_rm_descriptor, grim_data, plane=planes[i], planes[i].cd_p
   if((keyword_set(all)) OR (keyword_set(pd))) then $
     grim_rm_descriptor, grim_data, plane=planes[i], planes[i].pd_p
   if((keyword_set(all)) OR (keyword_set(rd))) then $
     grim_rm_descriptor, grim_data, plane=planes[i], planes[i].rd_p
   if((keyword_set(all)) OR (keyword_set(sd))) then $
     grim_rm_descriptor, grim_data, plane=planes[i], planes[i].sd_p
   if((keyword_set(all)) OR (keyword_set(std))) then $
     grim_rm_descriptor, grim_data, plane=planes[i], planes[i].std_p
   if((keyword_set(all)) OR (keyword_set(sund))) then $
     grim_rm_descriptor, grim_data, plane=planes[i], planes[i].sund_p

   if(keyword_set(all)) then *planes[i].active_xd_p = 0

   ;----------------------------------
   ; clear points arrays
   ;----------------------------------
   names = *planes[i].overlay_names_p
   for j=0, n_elements(names)-1 do $
    begin
     name = names[j]
     psp = grim_get_overlay_psp(grim_data, plane=planes[i], name, class=class)

     if(keyword_set(all)) then $
                *(grim_get_overlay_psp(grim_data, plane=planes[i], name)) = 0
    end

   if(keyword_set(all)) then *planes[i].active_overlays_psp = 0

   if(keyword_set(all)) then ptr_free, planes[i].user_ps_tlp	; Need to free all the pointers!!
   if(keyword_set(all)) then planes[i].user_ps_tlp = ptr_new()
  end

 grim_set_data, grim_data, grim_data.base

end
;=============================================================================



;=============================================================================
; grim_place_readout_mark
;
;=============================================================================
pro grim_place_readout_mark, grim_data, p

 ;------------------------
 ; erase old mark
 ;------------------------
 q = convert_coord(grim_data.readout_mark[0], grim_data.readout_mark[1], $
                                                           /data, /to_device)
 grim_display, grim_data, /use_pixmap, $
                pixmap_box_center=q[0:1], pixmap_box_side=10


 ;------------------------
 ; add new mark
 ;------------------------
 grim_data.readout_mark = p


 grim_set_data, grim_data, grim_data.base

end
;=============================================================================



;=============================================================================
; grim_place_measure_mark
;
;=============================================================================
pro grim_place_measure_mark, grim_data, p

 ;------------------------
 ; erase old mark
 ;------------------------
; q = convert_coord(grim_data.measure_mark[0], grim_data.measure_mark[1], $
;                                                           /data, /to_device)
; grim_display, grim_data, /use_pixmap, $
;                pixmap_box_center=q[0:1], pixmap_box_side=10


 ;------------------------
 ; add new mark
 ;------------------------
 grim_data.measure_mark = p


 grim_set_data, grim_data, grim_data.base

end
;=============================================================================



;=============================================================================
; grim_add_tiepoint
;
;=============================================================================
pro grim_add_tiepoint, grim_data, p, plane=plane
@pgs_include.pro

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 pgs_points, plane.tiepoints_ps, p=tp, flags=flags

 ;-----------------------------------------
 ; if no tiepoints exist ...
 ;-----------------------------------------
 if(NOT keyword_set(tp)) then $
        plane.tiepoints_ps = pgs_set_points(plane.tiepoints_ps, p=p) $
 ;----------------------------------------------------------------
 ; otherwise, find the first free slot and add the point
 ;----------------------------------------------------------------
 else $
  begin
   w = where(flags AND PGS_INVISIBLE_MASK)
   if(w[0] NE -1) then $
    begin 
     tp[*,w[0]] = p     
     flags[w[0]] = 0
    end $
   else $
    begin
     tp = tr([tr(tp), tr(p)])
     flags = [flags, 0]
    end

   plane.tiepoints_ps = pgs_set_points(plane.tiepoints_ps, p=tp, flags=flags)
  end 

 grim_set_plane, grim_data, plane, pn=plane.pn
 grim_set_data, grim_data, grim_data.base

end
;=============================================================================



;=============================================================================
; grim_copy_tiepoint
;
;=============================================================================
pro grim_copy_tiepoint, grim_data, plane, planes

 n = n_elements(planes)

 for i=0, n-1 do $
  begin
   pn = planes[i].pn
   grim_rm_tiepoint, grim_data, plane=planes[i], /all

   planes[i].tiepoints_ps = pgs_clone_ps(plane.tiepoints_ps)
   grim_set_plane, grim_data, planes[i], pn=pn
  end

 grim_set_data, grim_data, grim_data.base

end
;=============================================================================



;=============================================================================
; grim_get_tiepoint_indices
;
;=============================================================================
function grim_get_tiepoint_indices, grim_data, plane=plane
@pgs_include.pro

 if(NOT keyword__set(plane)) then plane = grim_get_plane(grim_data)

 pgs_points, plane.tiepoints_ps, flags=flags
 ii = where((flags AND PGS_INVISIBLE_MASK) EQ 0)

 return, ii
end
;=============================================================================



;=============================================================================
; grim_replace_tiepoints
;
;=============================================================================
pro grim_replace_tiepoints, grim_data, ii, p, plane=plane

 if(NOT keyword__set(plane)) then plane = grim_get_plane(grim_data)

 pgs_points, plane.tiepoints_ps, p=tp
 tp[*,ii] = p
 plane.tiepoints_ps = pgs_set_points(plane.tiepoints_ps, p=tp)

 grim_set_plane, grim_data, plane, pn=plane.pn
 grim_set_data, grim_data, grim_data.base
end
;=============================================================================



;=============================================================================
; grim_rm_tiepoint
;
;=============================================================================
pro grim_rm_tiepoint, grim_data, p, all=all, plane=plane
@pgs_include.pro

 if(NOT keyword__set(plane)) then plane = grim_get_plane(grim_data)

 pgs_points, plane.tiepoints_ps, p=tp, flags=flags

 if(NOT keyword__set(tp)) then return

 if(keyword__set(all)) then $
  begin
   nv_free, plane.tiepoints_ps
   plane.tiepoints_ps = {pg_points_struct}
   grim_set_plane, grim_data, plane, pn=plane.pn
   grim_set_data, grim_data, grim_data.base
   return
  end


d2min = 100

 ;-----------------------------------------------------
 ; compute distance from p to each tiepoint
 ;-----------------------------------------------------
 n = n_elements(flags)

 q = (convert_coord(/data, /to_device, p[0], p[1]))[0:1,*]
 tq = (convert_coord(/data, /to_device, tp[0,*], tp[1,*]))[0:1,*]

 qq = q#make_array(n,val=1d) 

 d2 = (qq[0,*]-tq[0,*])^2 + (qq[1,*]-tq[1,*])^2
 w = where(flags AND PGS_INVISIBLE_MASK)
 if(w[0] NE -1) then d2[w] = d2min + 1

 ;-----------------------------------------------------
 ; remove lowest-numbered tiepoint that's within range
 ;-----------------------------------------------------
 w = where(d2 LE d2min)
 if(w[0] EQ -1) then return

 flags[w[0]] = PGS_INVISIBLE_MASK
 plane.tiepoints_ps = $
             pgs_set_points(plane.tiepoints_ps, p=tp, flags=flags)

 grim_set_plane, grim_data, plane, pn=plane.pn
 grim_set_data, grim_data, grim_data.base

end
;=============================================================================



;=============================================================================
; grim_get_object_overlays
;
;  Returns all overlay arrays associated with the given xd.
;
;=============================================================================
function grim_get_object_overlays, plane, xd

 class = strlowcase(class_get(xd))
 xds = grim_get_xd(grim_data, plane=plane, class)
 if(NOT keyword_set(xds)) then return, 0

 w = where(xds EQ xd)

 ps = 0
 names = *plane.overlay_names_p
 for i=0, n_elements(names)-1 do $
  begin
   name = names[i]
   psp = grim_get_overlay_psp(grim_data, plane=plane, name, class=_class)
   if((keyword_set(*psp)) AND (_class EQ class)) then $
                                                ps = append_array(ps, (*psp)[*,w])
  end

 return, ps
end
;=============================================================================



;=============================================================================
; grim_get_associated_overlays
;
;=============================================================================
function grim_get_associated_overlays, plane, idp

 ps = grim_cat_points(grim_data, plane=plane)
 if(NOT keyword_set(ps)) then return, 0
 idps = nv_extract_idp(ps)

 w = where(idps EQ idp)
 if(w[0] EQ -1) then return, 0

 return, ps[w]
end
;=============================================================================



;=============================================================================
; grim_deactivate_xd
;
;=============================================================================
pro grim_deactivate_xd, plane, xds

 if(NOT keyword_set(xds)) then return
 if(NOT keyword_set(*plane.active_xd_p)) then return


 ;---------------------------------------------
 ; determine which xds are already active
 ;---------------------------------------------
 nxd = n_elements(xds)

 w = [-1]
 ww = lindgen(nxd)

 n_active = n_elements(*plane.active_xd_p)
 active_idp = ptrarr(n_active)
 for i=0, n_active-1 do active_idp[i] = nv_extract_idp((*plane.active_xd_p)[i])
 idp = nv_extract_idp(xds)

 w = nwhere(active_idp, idp)

 ;---------------------------------------------
 ; deactivate active objects
 ;---------------------------------------------
 if(w[0] NE -1) then $
  begin
    *plane.active_xd_p = rm_list_item(*plane.active_xd_p, w, only=0)
    if(NOT keyword_set((*plane.active_xd_p)[0])) then *plane.active_xd_p = 0
  end

end
;=============================================================================



;=============================================================================
; grim_deactivate_overlay
;
;=============================================================================
pro grim_deactivate_overlay, plane, ps, xds=xds, idps=idps, pps=pps

 if(NOT keyword__set(*plane.active_overlays_psp)) then return
 if(NOT keyword__set(ps)) then return

 ;---------------------------------------------
 ; determine which psp are already active
 ;---------------------------------------------
 nps = n_elements(ps)

 w = [-1]
 ww = lindgen(nps)

 pgs_points_ps, ps, p=p
 pgs_points_ps, *plane.active_overlays_psp, p=active_p
 w = nwhere(active_p, p)
 ww = complement(p, w)

 ;---------------------------------------------
 ; deactivate active objects
 ;---------------------------------------------
 if(w[0] NE -1) then $
  begin
    *plane.active_overlays_psp = $
                  rm_list_item(*plane.active_overlays_psp, w, only=0)
    if(NOT keyword__set((*plane.active_overlays_psp)[0])) then $
                                              *plane.active_overlays_psp = 0
  end

 ;--------------------------------------------------------------------
 ; If xds given, deactivate all overlays for a each descriptor.
 ; Note the recursive call.
 ;--------------------------------------------------------------------
 pps = ps
 if(keyword_set(xds)) then $
  begin
   nxds = n_elements(xds)
   for i=0, nxds-1 do $
    begin
     pps = grim_get_object_overlays(plane, xds[i])
     grim_deactivate_overlay, plane, pps
    end
  end

 ;--------------------------------------------------------------------
 ; If idps given, deactivate all overlays projected from the same xd 
 ; as the array with the given idp was.
 ; Note the recursive call.
 ;--------------------------------------------------------------------
 if(keyword_set(idps)) then $
  begin
   nidps = n_elements(idps)
   for i=0, nidps-1 do $
    begin
;     ps = grim_get_associated_overlays(plane, idps[i])
;     grim_deactivate_overlay, plane, ps
    end
  end


end
;=============================================================================



;=============================================================================
; grim_activate_xd
;
;=============================================================================
pro grim_activate_xd, plane, xds

 if(NOT keyword_set(xds)) then return

 w = where(ptr_valid(xds))
 if(w[0] EQ -1) then return
 xds = xds[w]

 ;---------------------------------------------
 ; determine which xds are already active
 ;---------------------------------------------
 nxd = n_elements(xds)

 w = [-1]
 ww = lindgen(nxd)

 if(keyword_set(*plane.active_xd_p)) then $
  begin
   n_active = n_elements(*plane.active_xd_p)
   active_idp = ptrarr(n_active)
   for i=0, n_active-1 do $
      active_idp[i] = nv_extract_idp((*plane.active_xd_p)[i])
   idp = nv_extract_idp(xds)

   w = nwhere(idp, active_idp)
   ww = complement(xds, w)
  end

 ;---------------------------------------------
 ; activate inactive objects
 ;---------------------------------------------
 if(ww[0] NE -1) then $
  begin
   if(NOT keyword_set(*plane.active_xd_p)) then $
                                         *plane.active_xd_p = xds[ww] $
   else *plane.active_xd_p = [*plane.active_xd_p, xds[ww]]
  end

 
end
;=============================================================================



;=============================================================================
; grim_deactivate_all_xds
;
;=============================================================================
pro grim_deactivate_all_xds, plane

 grim_deactivate_xd, plane, *plane.pd_p
 grim_deactivate_xd, plane, *plane.rd_p
 grim_deactivate_xd, plane, *plane.sd_p
 grim_deactivate_xd, plane, *plane.std_p

end
;=============================================================================



;=============================================================================
; grim_activate_all_xds
;
;=============================================================================
pro grim_activate_all_xds, plane

 grim_activate_xd, plane, *plane.pd_p
 grim_activate_xd, plane, *plane.rd_p
 grim_activate_xd, plane, *plane.sd_p
 grim_activate_xd, plane, *plane.std_p

end
;=============================================================================



;=============================================================================
; grim_activate_overlay
;
;=============================================================================
pro grim_activate_overlay, plane, ps, xds=xds, idps=idps, pps=pps

 if(NOT keyword_set(ps)) then return

 ;---------------------------------------------
 ; determine which psp are already active
 ;---------------------------------------------
 nps = n_elements(ps)

 w = [-1]
 ww = lindgen(nps)

 if(keyword_set(*plane.active_overlays_psp)) then $
  begin
   pgs_points_ps, ps, p=p
   pgs_points_ps, *plane.active_overlays_psp, p=active_p

   w = nwhere(p, active_p)				; which active
   ww = complement(ps, w)				; which inactive
  end

 ;---------------------------------------------
 ; activate inactive overlays
 ;---------------------------------------------
 if(ww[0] NE -1) then $
  begin
   if(NOT keyword_set(*plane.active_overlays_psp)) then $
                                     *plane.active_overlays_psp = ps[ww] $
   else *plane.active_overlays_psp = [*plane.active_overlays_psp, ps[ww]]
  end

 ;--------------------------------------------------------------------
 ; If xds given, activate all overlays for each descriptor.  
 ; Note the recursive call.
 ;--------------------------------------------------------------------
 pps = ps
 if(keyword_set(xds)) then $
  begin
   nxds = n_elements(xds)
   for i=0, nxds-1 do $
    begin
     pps = grim_get_object_overlays(plane, xds[i])
     grim_activate_overlay, plane, pps
    end
  end


 ;-----------------------------------------------------
 ; cull out any invalid activations
 ;-----------------------------------------------------
 *plane.active_overlays_psp = pgs_cull(*plane.active_overlays_psp)
 

end
;=============================================================================



;=============================================================================
; grim_activate_all_overlays
;
;=============================================================================
pro grim_activate_all_overlays, plane

 if(NOT keyword_set(*plane.overlay_psps)) then return

 n = n_elements(*plane.overlay_psps)
 for i=0, n-1 do grim_activate_overlay, plane, *(*plane.overlay_psps)[i]

 if(ptr_valid(plane.user_ps_tlp)) then $
  begin
   ww = lindgen(n_elements(*plane.user_ps_tlp))
   grim_activate_user_overlay, plane, ww
  end

 grim_update_activated, grim_data, plane=plane
end
;=============================================================================



;=============================================================================
; grim_deactivate_all_overlays
;
;=============================================================================
pro grim_deactivate_all_overlays, plane

 if(NOT keyword_set(*plane.overlay_psps)) then return

 n = n_elements(*plane.overlay_psps)
 for i=0, n-1 do grim_deactivate_overlay, plane, *(*plane.overlay_psps)[i]

 if(ptr_valid(plane.user_ps_tlp)) then $
  begin
   ww = lindgen(n_elements(*plane.user_ps_tlp))
   grim_deactivate_user_overlay, plane, ww
  end

 grim_update_activated, grim_data, plane=plane
end
;=============================================================================



;=============================================================================
; grim_invert_active_overlays
;
;=============================================================================
pro grim_invert_active_overlays, plane, ps, xds=xds

 if(NOT keyword_set(ps)) then return

 ;------------------------------------------------------
 ; determine which psp are currently active/inactive
 ;------------------------------------------------------
 nps = n_elements(ps)

 w = [-1]
 ww = lindgen(nps)

 if(keyword_set(*plane.active_overlays_psp)) then $
  begin
   pgs_points_ps, ps, p=p
   pgs_points_ps, *plane.active_overlays_psp, p=active_p

   w = nwhere(p, active_p)		; active
   ww = complement(ps, w)		; inactive
  end

 ;---------------------------------------------
 ; deactivate active objects
 ;---------------------------------------------
 if(w[0] NE -1) then grim_deactivate_overlay, plane, ps[w]

 ;---------------------------------------------
 ; activate previously inactive objects
 ;---------------------------------------------
 if(ww[0] NE -1) then grim_activate_overlay, plane, ps[ww]

 
 ;-----------------------------------------------------
 ; update object-referenced activation lists
 ;-----------------------------------------------------
 grim_update_activated, grim_data, plane=plane


end
;=============================================================================



;=============================================================================
; grim_invert_all_overlays
;
;=============================================================================
pro grim_invert_all_overlays, plane

 if(NOT keyword_set(*plane.overlay_psps)) then return

 n = n_elements(*plane.overlay_psps)
 for i=0, n-1 do $
    grim_invert_active_overlays, plane, *(*plane.overlay_psps)[i]

 grim_invert_active_user_overlays, plane

end
;=============================================================================



;=============================================================================
; grim_nearest_overlay
;
;=============================================================================
function grim_nearest_overlay, plane, p, object_ps, mm=mm

 if(NOT keyword_set(object_ps)) then return, -1

d2min = 25

 n = n_elements(object_ps)
 mins = dblarr(n)

 q = (convert_coord(p[0], p[1], /data, /to_device))[0:1]

 ;- - - - - - - - - - - - - - - - - - - - - - - - -
 ; find minimum distance to each object
 ;- - - - - - - - - - - - - - - - - - - - - - - - -
 for i=0, n-1 do $
  begin
   pgs_visible_points, object_ps[i], p=pts, desc=desc
   npts = n_elements(pts)/2
   if(npts GT 0) then $
    begin
     pp = (convert_coord(pts[0,*], pts[1,*], /data, /to_device))[0:1,*]
     qq = q#make_array(npts,val=1d) 
     d2 = (qq[0,*]-pp[0,*])^2 + (qq[1,*]-pp[1,*])^2
     mins[i] = min(d2)
    end $
   else mins[i] = 1d20
  end

 ;- - - - - - - - - - - - - - - - - - - - - - - - -
 ; activate or deactivate closest in-range object
 ;- - - - - - - - - - - - - - - - - - - - - - - - -
 mm = min(mins)
 ww = where(mins EQ mm)
 if(mm LE d2min) then return, ww     


 return, -1
end
;=============================================================================



;=============================================================================
; grim_enclosed_overlays
;
;=============================================================================
function grim_enclosed_overlays, plane, corners, object_ps, mm=mm

 if(NOT keyword__set(object_ps)) then return, -1

 n = n_elements(object_ps)

 ;-------------------------------------------
 ; find minimum distance to each object
 ;-------------------------------------------
 ww = -1
 for i=0, n-1 do $
  begin
   pgs_visible_points, (object_ps)[i], p=pts
   npts = n_elements(pts)/2
   if(npts GT 0) then $
    begin
     xmin = make_array(npts, val=min(corners[0,*]))
     xmax = make_array(npts, val=max(corners[0,*]))
     ymin = make_array(npts, val=min(corners[1,*]))
     ymax = make_array(npts, val=max(corners[1,*]))

     w = where((pts[0,*] GT xmax) OR (pts[0,*] LT xmin) $
                   OR (pts[1,*] GT ymax) OR (pts[1,*] LT ymin))
     if(w[0] EQ -1) then ww = [ww, i]
    end
  end

 if(n_elements(ww) GT 1) then ww = ww[1:*]

 return, ww
end
;=============================================================================



;=============================================================================
; grim_remove_by_point
;
;=============================================================================
function grim_remove_by_point, plane, p0, clicks=clicks, user=user

d2min = 25

 ;---------------------------------
 ; get get data coords of point
 ;---------------------------------
 p = convert_coord(p0[0], p0[1], /device, /to_data)

 ;---------------------------------------------------------------------
 ; compute distance from p to each overlay point for each object type
 ;---------------------------------------------------------------------
 if(NOT keyword_set(user)) then $
  begin
   ww = -1 & mm = 1d20
   found = 1

   names = *plane.overlay_names_p
   for i=0, n_elements(names)-1 do $
    begin
     _name = names[i]
;     ps = grim_get_active_overlays(grim_data, plane=plane, _name)
     psp = grim_get_overlay_psp(grim_data, plane=plane, _name)
     _ww = grim_nearest_overlay(plane, p, *psp, mm=_mm)
     if(_ww[0] NE -1) then if(_mm LT mm) then $
      begin
       name = _name
       mm = _mm
       ww = _ww
      end
    end

   ;------------------------------------------------------------------
   ; activate or deactivate objects
   ;------------------------------------------------------------------
   if(keyword_set(name)) then $
    begin
     psp = grim_get_overlay_psp(grim_data, plane=plane, name, class=class)
     xd = grim_get_xd(grim_data, plane=plane, class)
     nd = n_elements(xd)
     nps = n_elements(*psp)/nd
     ww_xd = ww / nps

     fn_overlay = 'grim_activate_overlay'

     psp = grim_get_overlay_psp(grim_data, plane=plane, name, class=class)
     xd = 0

;     if((clicks EQ 2) AND (ww_xd[0] NE -1)) then $
;                        xd = (grim_get_xd(grim_data, plane=plane, class))[ww_xd[0]]
;here, we'd like to remove the associated xd, as well as all its points
; not yet implemented, though

     if(ww[0] NE -1) then grim_rm_points, plane, psp, ww[0]

     return, 0
    end
  end

 ;--------------
 ; user points
 ;--------------
 if(keyword_set(user)) then $
  begin
   if(ptr_valid(plane.user_ps_tlp)) then $
    begin
     all_tags = (*plane.user_ps_tlp).name
     user_ps = grim_get_user_ps(all_tags, plane=plane)
     ww_usr = grim_nearest_overlay(plane, p, user_ps)

     if(ww_usr[0] NE -1) then $
      begin
       grim_clear_user_overlays, plane, all_tags[ww_usr]
       return, 0
      end
    end 
  end

 grim_update_activated, grim_data, plane=plane

 return, -1
end
;=============================================================================



;=============================================================================
; grim_activate_by_point
;
;=============================================================================
function grim_activate_by_point, plane, p0, deactivate=deactivate, clicks=clicks

d2min = 25

 ;---------------------------------
 ; get get data coords of point
 ;---------------------------------
 p = convert_coord(p0[0], p0[1], /device, /to_data)

 ;---------------------------------------------------------------------
 ; compute distance from p to each overlay point for each object type
 ;---------------------------------------------------------------------
 ww = -1 & mm = 1d20
 found = 1

 names = *plane.overlay_names_p
 for i=0, n_elements(names)-1 do $
  begin
   _name = names[i]
   psp = grim_get_overlay_psp(grim_data, plane=plane, _name)
   _ww = grim_nearest_overlay(plane, p, *psp, mm=_mm)
   if(_ww[0] NE -1) then if(_mm LT mm) then $
    begin
     name = _name
     mm = _mm
     ww = _ww
    end
  end

 ;------------------------------------------------------------------
 ; activate or deactivate objects
 ;------------------------------------------------------------------
 if(keyword_set(name)) then $
  begin
   psp = grim_get_overlay_psp(grim_data, plane=plane, name, class=class)
   xd = grim_get_xd(grim_data, plane=plane, class)
   nd = n_elements(xd)
   nps = n_elements(*psp)/nd
   ww_xd = ww / nps

   fn_overlay = 'grim_activate_overlay'
   if(keyword_set(deactivate)) then fn_overlay = 'grim_deactivate_overlay'

   xd = 0
   if((clicks EQ 2) AND (ww_xd[0] NE -1)) then $
                        xd = (grim_get_xd(grim_data, plane=plane, class))[ww_xd[0]]

   if(ww[0] NE -1) then $
    begin
     ps = (*psp)[ww[0]]
     call_procedure, fn_overlay, plane, ps, xd=xd, pps=pps
     grim_set_overlay_update_flag, pps, 1
    end

   return, 0
  end

 ;--------------
 ; user points
 ;--------------
 if(ptr_valid(plane.user_ps_tlp)) then $
  begin
   all_tags = (*plane.user_ps_tlp).name
   user_ps = grim_get_user_ps(all_tags, plane=plane)
   ww_usr = grim_nearest_overlay(plane, p, user_ps)

   if(ww_usr[0] NE -1) then $
    begin
     if(keyword__set(deactivate)) then grim_deactivate_user_overlay, plane, ww_usr $
     else grim_activate_user_overlay, plane, ww_usr
     return, 0
    end
  end 

 return, -1
end
;=============================================================================



;=============================================================================
; grim_trim_overlays
;
;=============================================================================
pro grim_trim_overlays, grim_data, plane=plane, region

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 names = *plane.overlay_names_p
 for i=0, n_elements(names)-1 do $
  begin
   name = names[i]
   ps = *(grim_get_overlay_psp(grim_data, plane=plane, name))
   if(keyword_set(ps)) then pg_trim, 0, ps, region
  end

end
;=============================================================================



;=============================================================================
; grim_remove_by_box
;
;=============================================================================
pro grim_remove_by_box, plane, cx, cy, stat=stat, user=user

 stat = 1

 ;---------------------------------
 ; get get data coords of corners
 ;---------------------------------
 corners = convert_coord(cx, cy, /device, /to_data)


 ;-------------------------------------
 ; scan overlays for inclusion in box
 ;-------------------------------------

 ;- - - - - - - - - - - - -
 ; standard overlays
 ;- - - - - - - - - - - - -
 if(NOT keyword_set(user)) then $
  begin
   names = *plane.overlay_names_p
   for i=0, n_elements(names)-1 do $
    begin
     stat = 0
     name = names[i]
     psp = grim_get_overlay_psp(grim_data, plane=plane, name, class=class)
     ww = grim_enclosed_overlays(plane, corners, *psp)
     if(ww[0] NE -1) then $
      begin
       xd = grim_get_xd(grim_data, plane=plane, class)
       nd = n_elements(xd)
       nps = n_elements(*psp)/nd
       ww_xd = ww / nps

       fn_overlay = 'grim_activate_overlay'

       xd = 0
       if(ww_xd[0] NE -1) then $
                        xd = (grim_get_xd(grim_data, plane=plane, class))[ww_xd[0]]
       if(ww[0] NE -1) then grim_rm_points, plane, psp, ww
      end

    end
  end


 ;- - - - - - - - - - - - -
 ; user overlays
 ;- - - - - - - - - - - - -
 if(keyword_set(user)) then $
  begin
   if(ptr_valid(plane.user_ps_tlp)) then $
    begin
     stat = 0
     all_tags = (*plane.user_ps_tlp).name
     user_ps = grim_get_user_ps(all_tags, plane=plane)
     ww_usr = grim_enclosed_overlays(plane, corners, user_ps)

     if(ww_usr[0] NE -1) then $
                        grim_clear_user_overlays, plane, all_tags[ww_usr]
    end
  end

 grim_update_activated, grim_data, plane=plane
end
;=============================================================================



;=============================================================================
; grim_activate_by_box
;
;=============================================================================
pro grim_activate_by_box, plane, cx, cy, deactivate=deactivate

 ;---------------------------------
 ; get get data coords of corners
 ;---------------------------------
 corners = convert_coord(cx, cy, /device, /to_data)


 ;-------------------------------------
 ; scan overlays for inclusion in box
 ;-------------------------------------

 ;- - - - - - - - - - - - -
 ; standard overlays
 ;- - - - - - - - - - - - -
 names = *plane.overlay_names_p
 for i=0, n_elements(names)-1 do $
  begin
   name = names[i]
   psp = grim_get_overlay_psp(grim_data, plane=plane, name, class=class)
   ww = grim_enclosed_overlays(plane, corners, *psp)
   if(ww[0] NE -1) then $
    begin
     fn_overlay = 'grim_activate_overlay'
     if(keyword_set(deactivate)) then fn_overlay = 'grim_deactivate_overlay'

     psp = grim_get_overlay_psp(grim_data, plane=plane, name, class=class)
     if(ww[0] NE -1) then $
      begin
       ps = (*psp)[ww]
       grim_set_overlay_update_flag, ps, 1
       call_procedure, fn_overlay, plane, ps, xd=xd
      end
    end

  end

 ;- - - - - - - - - - - - -
 ; user overlays
 ;- - - - - - - - - - - - -
 if(ptr_valid(plane.user_ps_tlp)) then $
  begin
   all_tags = (*plane.user_ps_tlp).name
   user_ps = grim_get_user_ps(all_tags, plane=plane)
   ww_usr = grim_enclosed_overlays(plane, corners, user_ps)

   if(ww_usr[0] NE -1) then $
    begin
     if(keyword_set(deactivate)) then grim_deactivate_user_overlay, plane, ww_usr $
     else grim_activate_user_overlay, plane, ww_usr
    end
  end

end
;=============================================================================



;=============================================================================
; grim_activate_select
;
;=============================================================================
pro grim_activate_select, plane, p0, deactivate=deactivate, clicks=clicks, ps=ps

d2min = 9

 ;---------------------------------------------
 ; select overlay under initial cursor point
 ;---------------------------------------------
 stat = grim_activate_by_point(plane, p0, deactivate=deactivate, clicks=clicks)

 ;-----------------------------------------------------------------------------
 ; if nothing selected by the initial click, get user-defined box on image
 ;-----------------------------------------------------------------------------
 if(stat EQ -1) then $
  begin
   ;- - - - - - - - - - - - - - -
   ; drag box
   ;- - - - - - - - - - - - - - -
   box = tvrec(/restore, p0=p0, col=ctgreen())

   cx = box[0,*]
   cy = box[1,*]
   d2 = (cx[0] - cx[1])^2 + (cy[0] - cy[1])^2 
 
   ;- - - - - - - - - - - - - - - - - - - - - - - -
   ; select overlays inside box, if dragged
   ;- - - - - - - - - - - - - - - - - - - - - - - -
   box = 1
   if(d2 LE d2min) then box = 0

   if(box) then grim_activate_by_box, plane, cx, cy, deactivate=deactivate
  end

 grim_update_activated, grim_data, plane=plane
end
;=============================================================================



;=============================================================================
; grim_remove_overlays
;
;=============================================================================
pro grim_remove_overlays, plane, p0, clicks=clicks, stat=stat, user=user

d2min = 9

 ;---------------------------------------------
 ; select overlay under initial cursor point
 ;---------------------------------------------
 stat = grim_remove_by_point(plane, p0, clicks=clicks, user=user)

 ;-----------------------------------------------------------------------------
 ; if nothing selected by the initial click, get user-defined box on image
 ;-----------------------------------------------------------------------------
 if(stat EQ -1) then $
  begin
   ;- - - - - - - - - - - - - - -
   ; drag box
   ;- - - - - - - - - - - - - - -
   box = tvrec(/restore, p0=p0, col=ctblue())

   cx = box[0,*]
   cy = box[1,*]
   d2 = (cx[0] - cx[1])^2 + (cy[0] - cy[1])^2 
 
   ;- - - - - - - - - - - - - - - - - - - - - - - -
   ; select overlays inside box, if dragged
   ;- - - - - - - - - - - - - - - - - - - - - - - -
   box = 1
   if(d2 LE d2min) then box = 0

   if(box) then grim_remove_by_box, plane, cx, cy, stat=stat, user=user
  end

end
;=============================================================================



;=============================================================================
; grim_create_overlay
;
;=============================================================================
pro grim_create_overlay, grim_data, plane, name, class, dep_classes, dep_overlays, $
                   color=color, psym=psym, symsize=symsize, shade=shade, $
                   tlab=tlab, tshade=tshade, tfill=tfill

 if(NOT defined(symsize)) then symsize = 1.
 if(NOT defined(shade)) then shade = 1.
 
 *plane.overlay_names_p = append_array(*plane.overlay_names_p, name)
 *plane.overlay_classes_p = append_array(*plane.overlay_classes_p, [class])
 *plane.overlay_dep_p = append_array(*plane.overlay_dep_p, ptr_new(dep_classes))
 *plane.overlay_labels_p = append_array(*plane.overlay_labels_p, ptr_new(''))
 *plane.overlay_psps = append_array(*plane.overlay_psps, ptr_new(0))

 *plane.overlay_color_p = append_array(*plane.overlay_color_p, color)
 *plane.overlay_symsize_p = append_array(*plane.overlay_symsize_p, [symsize])
 *plane.overlay_shade_p = append_array(*plane.overlay_shade_p, [shade])
 *plane.overlay_psym_p = append_array(*plane.overlay_psym_p, psym)
 *plane.overlay_tlab_p = append_array(*plane.overlay_tlab_p, [tlab])
 *plane.overlay_tshade_p = append_array(*plane.overlay_tshade_p, [tshade])
 *plane.overlay_tfill_p = append_array(*plane.overlay_tfill_p, [tfill])
 *plane.overlay_data_p = append_array(*plane.overlay_data_p, [ptr_new(0)])

end
;=============================================================================



;=============================================================================
; grim_create_overlays
;
;=============================================================================
pro grim_create_overlays, grim_data, plane

   grim_create_overlay, grim_data, plane, $
                   'limb_fill',          col='yellow', psym=3, tlab=0, tfill=1, shade=0, tshade=1, $
      'planet', 	['sun', 'ring']

   grim_create_overlay, grim_data, plane, $
                   'ring_fill',          col='orange', psym=3, tlab=0, tfill=1, shade=0, tshade=1, $
      'ring', 		['sun', 'planet', 'ring']

   grim_create_overlay, grim_data, plane, $
                   'ring_grid',     col='orange',   psym=3, tlab=0, tfill=0, tshade=1, $
      'ring', 		['sun', 'planet', 'ring']

   grim_create_overlay, grim_data, plane, $
                   'planet_grid',   col='yellow',   psym=3, tlab=0, tfill=0, tshade=1, $
      'planet', 	['sun', 'ring']

   grim_create_overlay, grim_data, plane, $
                   'station',   col='pink',   psym=5, tlab=1, tfill=0, tshade=1, $
      'station', 	['planet', 'sun', 'ring']

   grim_create_overlay, grim_data, plane, $
                   'limb',          col='yellow', psym=3, tlab=0, tfill=0, shade=0, tshade=1, $
      'planet', 	['sun', 'ring']

   grim_create_overlay, grim_data, plane, $
                   'terminator',    col='red',  psym=3, tlab=0, tfill=0, tshade=1, $
      'planet', 	['sun', 'ring']

   grim_create_overlay, grim_data, plane, $
                   'ring',          col='orange',    psym=3, tlab=0, tfill=0, tshade=1, $
      'ring',	 	['sun', 'planet', 'ring']

   grim_create_overlay, grim_data, plane, $
                   'planet_center', col='white',    psym=1, tlab=1, tfill=0, tshade=1, $
      'planet',		['sun']

   grim_create_overlay, grim_data, plane, $
                   'star',          col='white',  psym=6, tlab=0, tfill=0, symsize=0, tshade=1, $
      'star', 		['planet', 'ring']

   grim_create_overlay, grim_data, plane, $
                   'shadow',         col='purple', psym=3, tlab=0, tfill=0, tshade=1, $
	'', 		['planet', 'ring', 'sun']


end
;=============================================================================



;=============================================================================
; grim_hide
;
;=============================================================================
pro grim_hide, grim_data, plane, ps, gd=gd

 if(keyword__set(gd.rd)) then $
        pg_hide, ps, cd=gd.cd, dkx=gd.rd, od=od, /disk, gbx=gd.pd
 grim_message

 if(keyword__set(gd.sund)) then $
;     pg_hide, ps, cd=gd.cd, gbx=pds, od=gd.sund, /limb
     pg_hide, ps, cd=gd.cd, gbx=gd.pd, od=gd.sund, /globe
 grim_message


end
;=============================================================================



;=============================================================================
; grim_overlay
;
;=============================================================================
pro grim_overlay, grim_data, name, plane=plane, dep=dep, ps=ps, $
                                   obj_name=obj_name, replace=replace, temp=temp

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 ;------------------------------------------------
 ; get points array
 ;------------------------------------------------
 psp = grim_get_overlay_psp(grim_data, name, plane=plane, class=class, data=data) 
 fn = 'grim_compute_' + name


 ;--------------------------------------------------
 ; if the dependencies are given, then just update
 ;  existing arrays
 ;--------------------------------------------------
 if(keyword_set(dep)) then $
  begin
   ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   ; get the relevant descriptors and recompute the overlay points
   ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   dep_xds = grim_get_xd(grim_data, plane=plane, 'all', idps=idps)
   gd = pgs_idp_to_gd(dep, dep_xds)

   _ps = call_function(fn, gd=gd, $
          map=grim_test_map(grim_data), fov=plane.fov, hide=plane.hide, $
          active_ps=ps, data=data, $
          npoints=grim_data.npoints)

   ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   ; update the existing overlay array
   ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   pgs_points_ps, ps, inp=inp, desc=desc
   n = n_elements(_ps)
   for i=0, n-1 do if(pgs_valid(_ps[i])) then $
    begin
     pgs_points, _ps[i], points=points, inp=_inp, desc=_desc, flags=flags
     w = where(desc+inp EQ _desc+_inp)
     if(w[0] NE -1) then $
      begin
       if(n_elements(w) EQ 1) then $
          ps[w] = pgs_set_points(ps[w], points=points, flags=flags)
      end
    end
   return
  end


 ;---------------------------------------------------------
 ; otherwise create new arrays
 ;---------------------------------------------------------
 grim_suspend_events 

 ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
 ; make sure relevant descriptors are loaded
 ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
 grim_load_descriptors, grim_data, name, plane=plane, $
       idp_cam=idp_cam, idp_plt=idp_plt, idp_rng=idp_rng, $
       idp_sun=idp_sun, idp_str=idp_str, idp_stn=idp_stn, replace=replace, gd=gd

 ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
 ; compute overlay arrays
 ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
 active_xds = *plane.active_xd_p
 if(keyword_set(obj_name)) then $
  begin
   xds = pgs_cat_gd(gd)
   w = nwhere(cor_name(xds), obj_name)
   if(w[0] EQ -1) then return
   active_xds = xds[w]
  end

 ps = call_function(fn, gd=gd, idp_each=idp_each, data=data, select=select, $
          map=grim_test_map(grim_data), fov=plane.fov, hide=plane.hide, over=over, $
          active_xds=active_xds, active_ps=*plane.active_overlays_psp, $
          npoints=grim_data.npoints)
 if(NOT pgs_valid(ps)) then return

 ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
 ; add overlays
 ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
 if(NOT keyword_set(temp)) then $
   grim_add_points, grim_data, plane=plane, ps, select=select, $
         name=name, /replace, $
         idp_cam=idp_cam, idp_each=idp_each, data=data, over=over

 grim_resume_events

end
;=============================================================================



