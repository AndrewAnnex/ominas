;==============================================================================
; orb_construct_descriptor
;
;  Epoch of returned descriptor is the same as that of gbx.  
; 
;==============================================================================
function orb_construct_descriptor, gbx, $
		name=name, $
		sma=_sma, $		; Semimajor axis
		ecc=_ecc, $		; Eccentricity
		inc=_inc, $		; Inclination
		lan=_lan, $		; Lon. asc. node
		ap=_ap, $		; Arg. Periapse
		lp=_lp, $
		ma=_ma, $		; Mean anom. at epoch
		ml=_ml, $		; Mean lon.; instead of ma
		ta=_ta, $		; True anom.; instead of ma
		tl=_tl, $		; True lon.; instead of ma
		dmldt=_dmldt, $		; Sidereal mean motion
		dmadt=_dmadt, $		; Kepler mean motion
		dlandt=_dlandt, $
		liba_lan=_liba_lan, $
		libp_lan=_libp_lan, $
		libt_lan=_libt_lan, $
		dapdt=_dapdt, $
		liba_ap=_liba_ap, $
		libp_ap=_libp_ap, $
		libt_ap=_libt_ap, $
		dlpdt=_dlpdt, $
		mm=mm, $
		em=em, $
		_lpm=lpm, $
		dlpmdt=dlpmdt, $
		time=time, $		; Epoch at which given elements apply,
					;  if different than gbx
		ppt=ppt, $		; Time of last pericenter passage
		rd0=rd0, $		; Orbit descriptor at epoch t.
		ring=ring, $		; If set, ma and dmadt are not included
		GG=GG, noevolve=noevolve

; Note: ta and tl not yet implemented.
if(defined(ta)) then message, /con, 'WARNING: ta not implemented.'
if(defined(tl)) then message, /con, 'WARNING: tl not implemented.'

 if(defined(time)) then t = time
 if(NOT defined(t)) then t = bod_time(gbx)

 dt = bod_time(gbx) - t
 gbxt = glb_evolve(gbx, -dt)
 bd = class_extract(gbxt, 'BODY')

 sma = (ecc = tr([0d,0d]))
 if(defined(_sma)) then sma = tr([_sma,0])
 if(defined(_ecc)) then ecc = tr([_ecc,0])
 
 if(defined(_inc)) then inc = _inc
 if(defined(_lan)) then lan = _lan
 if(defined(_ap)) then ap = _ap
 if(defined(_lp)) then lp = _lp
 if(defined(_ma)) then ma = _ma
 if(defined(_ml)) then ml = _ml
 if(defined(_dmldt)) then dmldt = _dmldt
 if(defined(_dmadt)) then dmadt = _dmadt
 if(defined(_dlandt)) then dlandt = _dlandt
 if(defined(_dapdt)) then dapdt = _dapdt
 if(defined(_liba_ap)) then liba_ap = _liba_ap
 if(defined(_libp_ap)) then libp_ap = _libp_ap
 if(defined(_libt_ap)) then libt_ap = _libt_ap
 if(defined(_dlpdt)) then dlpdt = _dlpdt

 rd = rng_init_descriptors(1, $
		name=name, $
		primary = get_core_name(gbxt), $
		orient = bod_orient(orb_inertialize(gbxt)), $
		pos = bod_pos(gbxt), $
                time = t, $
                sma=sma, $
                ecc=ecc )

 if(defined(inc)) then orb_set_inc, rd, bd, inc

 if(NOT defined(dlandt)) then dlandt = orb_compute_dlandt(rd, gbxt, GG=GG)

 if(defined(dlpdt)) then dapdt = dlpdt - dlandt
 if(NOT defined(dapdt)) then dapdt = orb_compute_dapdt(rd, gbxt, GG=GG)

; if(NOT defined(dmldt)) then dmldt = orb_compute_dmldt(rd, gbxt, GG=GG)
 if(defined(dmldt)) then dmadt = dmldt - dlandt - dapdt
 if(NOT defined(dmadt)) then dmadt = orb_compute_dmadt(rd, gbxt, GG=GG)

 orb_set_dlandt, rd, bd, dlandt
 orb_set_dapdt, rd, bd, dapdt 
 if(NOT keyword_set(ring)) then orb_set_dmadt, rd, dmadt

 if(defined(lan)) then orb_set_lan, rd, bd, lan
 if(defined(lp)) then ap = orb_lon_to_arg(rd, lp, bd)
 if(defined(ap)) then orb_set_ap, rd, bd, ap
 if(defined(lan)) then orb_set_lan, rd, bd, lan		; this is not redundant!!

 if(defined(liba_ap)) then orb_set_liba_ap, rd, bd, liba_ap
 if(defined(libp_ap)) then orb_set_libp_ap, rd, bd, libp_ap
 if(defined(libt_ap)) then orb_set_libt_ap, rd, bd, libt_ap 

 if(defined(liba_lan)) then orb_set_liba_lan, rd, bd, liba_lan
 if(defined(libp_lan)) then orb_set_libp_lan, rd, bd, libp_lan
 if(defined(libt_lan)) then orb_set_libt_lan, rd, bd, libt_lan 

; if(defined(ppt)) then ma = ma + dmadt*(t - ppt)
 if(defined(ppt)) then ma = dmadt*(t - ppt)
 if(defined(ml)) then ma = orb_lon_to_anom(rd, ml, bd)
 if(NOT keyword_set(ring)) then if(defined(ma)) then orb_set_ma, rd, ma

 if(keyword_set(mm)) then $
  begin
   nmm = n_elements(mm)
;   if(NOT defined(wmm)) then wmm = lindgen(nmm)
;   nmm = n_elements(wmm)

;   __mm = dsk_m(rd) & __mm[0:nmm-1] = mm[wmm] & dsk_set_m, rd, __mm
;   __em = dsk_em(rd) & __em[0:nmm-1] = em[wmm] & dsk_set_em, rd, __em
;   __lpm = dsk_lpm(rd) & __lpm[0:nmm-1] = lpm[wmm] & dsk_set_lpm, rd, __lpm
;   __dlpmdt = dsk_dlpmdt(rd) & __dlpmdt[0:nmm-1] = dlpmdt[wmm] & dsk_set_dlpmdt, rd, __dlpmdt

   __mm = dsk_m(rd) & __mm[0:nmm-1] = mm & dsk_set_m, rd, __mm
   __em = dsk_em(rd) & __em[0:nmm-1] = em & dsk_set_em, rd, __em
   __lpm = dsk_lpm(rd) & __lpm[0:nmm-1] = lpm & dsk_set_lpm, rd, __lpm
   __dlpmdt = dsk_dlpmdt(rd) & __dlpmdt[0:nmm-1] = dlpmdt & dsk_set_dlpmdt, rd, __dlpmdt
  end  


 ;------------------------------
 ; evolve elements to gbx epoch
 ;-------------------------------
 if(NOT keyword_set(noevolve)) then $
  begin
   if(NOT keyword_set(ring)) then rdt = orb_evolve(rd, dt) $
   else rdt = rng_evolve(rd, dt)

   if(NOT arg_present(rd0)) then nv_free, rd
  end $
 else rdt = rd

 rd0 = rd

 nv_free, gbxt

 bod_set_pos, rdt, bod_pos(gbx)

 return, rdt
end
;==============================================================================
