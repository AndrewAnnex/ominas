;===========================================================================
; glb_intersect_points.pro
;
; Inputs and outputs are in globe body coordinates.
;
; Points that do not intersect are returned as the zero vector.
;
; v and r must have same number of elements
;
; returned array is (2*nv,3,nt); 1st half is near points, 
;  2nd half is far points.
;
;===========================================================================
function glb_intersect_points, gbdp, v, r, discriminant, alpha, beta, gamma
@nv_lib.include

 nt = n_elements(gbdp)
 nv = (size(v))[1]

 points = dblarr(2*nv,3,nt)

 sub = where(discriminant GE 0)

 if(sub[0] NE -1) then $
  begin
   ww = colgen(nv,3,nt, sub)
   sqd = sqrt(discriminant[sub])

   b = beta[sub]
   g = gamma[sub]

   tclose = ((-b - sqd)/g) # make_array(3, val=1d)
   tfar = ((-b + sqd)/g) # make_array(3, val=1d)

   pp = v[ww] + r[ww]*tclose
   qq = v[ww] + r[ww]*tfar

   points_close = dblarr(nv,3,nt)
   points_far = dblarr(nv,3,nt)
   points_close[ww] = pp
   points_far[ww] = qq

   points[0:nv-1,*,*] = points_close
   points[nv:*,*,*] = points_far
  end


 return, points
end
;===========================================================================
