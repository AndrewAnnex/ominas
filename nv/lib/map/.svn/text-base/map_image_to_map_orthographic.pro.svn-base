;===========================================================================
; map_image_to_map_orthographic
;
; Inverse orthographic projection for the sphere.  See [1], p.150.
;
; References:
;	[1] Snyder (1987)
;	    Map projections -- A working manual
;	    USGS professional paper 1395
;
;===========================================================================
function map_image_to_map_orthographic, mdp, _image_pts, valid=valid
@nv_lib.include
 md = nv_dereference(mdp)

 nt = n_elements(md)
 sv = size(_image_pts)
 nv = 1
 if(sv[0] GT 1) then nv = sv[2]

 _image_pts = reform(_image_pts, 2,nv*nt, /over)

 result = dblarr(2,nv*nt)

 R = 0.5*min(md.size)*md.scale

 image_pts = dblarr(2,nv*nt, /nozero)
 image_pts[0,*] = _image_pts[0,*] - md.origin[0]
 image_pts[1,*] = _image_pts[1,*] - md.origin[1]


 rho = sqrt(image_pts[0,*]^2 + image_pts[1,*]^2)
 valid = where(rho LT R)
 if(valid[0] EQ -1) then $
  begin
   _image_pts = reform(_image_pts, 2,nv,nt, /over)
   return, 0
  end

 rho = rho[valid]
 c = asin(rho/R) 


 result[0,valid] = $
       asin(cos(c)*sin(md.center[0]) + $
            (image_pts[1,valid]*sin(c)*cos(md.center[0])/rho)) / md.units[0]

 result[1,valid] = $
        md.center[1] + $
           atan(image_pts[0,valid]*sin(c), $
              (rho*cos(md.center[0])*cos(c) - $
                  image_pts[1,valid]*sin(md.center[0])*sin(c))) / md.units[1]

 result = reform(result, 2,nv,nt, /over)


 _image_pts = reform(_image_pts, 2,nv,nt, /over)
 return, result
end
;===========================================================================



