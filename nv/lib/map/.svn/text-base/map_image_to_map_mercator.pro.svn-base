;===========================================================================
; immc_fn
;
;===========================================================================
function immc_fn, x, data

 t = data[0,*]
 e = data[1,*]

 return, 0.5d*!dpi - 2d*atan(t*((1d - e*sin(x))/(1d + e*sin(x)))^(e/2d))
end
;===========================================================================


;===========================================================================
; map_image_to_map_mercator
;
; Inverse mercator projection for the oblate spheroid.  See [1], p.45.
;
; References:
;	[1] Snyder (1987)
;	    Map projections -- A working manual
;	    USGS professional paper 1395
;
;===========================================================================
function map_image_to_map_mercator, mdp, _image_pts, valid=valid
@nv_lib.include
 md = nv_dereference(mdp)

 ecc = map_radii_to_ecc(md.radii)

 nt = n_elements(md)
 sv = size(_image_pts)
 nv = 1
 if(sv[0] GT 1) then nv = sv[2]

 _image_pts = reform(_image_pts, 2,nv*nt, /over)

 result = dblarr(2,nv*nt)


 image_pts = dblarr(2,nv*nt, /nozero)
 image_pts[0,*] = _image_pts[0,*] - md.origin[0]
 image_pts[1,*] = _image_pts[1,*] - md.origin[1]

 
; The old approach was to force the scaling to be the same in both direcions, 
; regardless of the map dimensions.  The new approach is to scale the full range
; of lat and lon to each dimension, allowing the user to vary it using the
; 'units' field.
; a = min([md.size[0], 2d*md.size[1]])/2d/!dpi * md.scale * md.units
 a = [md.size[1]/!dpi, md.size[0]/2d/!dpi] * md.scale * md.units

 lon = image_pts[0,*]/a[1] + md.center[1]
 valid = where((lon-md.center[1] GE -!dpi) AND (lon-md.center[1] LE !dpi))
 if(valid[0] EQ -1) then $
  begin
   _image_pts = reform(_image_pts, 2,nv,nt, /over)
   return, 0
  end

 result[1,valid] = lon[valid]
 lon = 0

 t = exp(-image_pts[1,valid]/a[0])
 data = dblarr(2,n_elements(valid))
 data[0,*] = t
 data[1,*] = ecc

 result[0,valid] = 0.5d*!dpi - 2d*atan(t)
 result[0,valid] = trans_solve('immc_fn', result[0,valid], data)

 result = reform(result, 2,nv,nt, /over)


 _image_pts = reform(_image_pts, 2,nv,nt, /over)
 return, result
end
;===========================================================================



