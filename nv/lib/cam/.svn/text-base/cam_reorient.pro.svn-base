;===========================================================================
; cam_reorient.pro
;
; cd		 array(nt) or array(1,nt)
; image_axis	 array(2,1,nt)
; dxy		 array(2,1,nt)
; dtheta	 array(1,1,nt)
; 
;===========================================================================
pro cam_reorient, _cdp, image_axis, dxy, dtheta, $
                      n=n, sin_angle=sin_angle, cos_angle=cos_angle
 @nv_lib.include

 nt = n_elements(_cdp)

 ;---------------------------------
 ; eliminate degenerate dimension
 ;---------------------------------
 s = size(_cdp)
 reformed=0

 if(s[0] EQ 2) then $
  begin
   reformed=1
   cdp = reform(_cdp, nt)
  end $
 else cdp=_cdp


 ;-------------------------------------------------------
 ; on-axis image points; before and after reorientation
 ;-------------------------------------------------------
 p0 = image_axis
 p1 = image_axis + dxy

 ;----------------------------------
 ; choose an off-axis image point
 ;----------------------------------
 r = 100d
 dr = ([r,0.])[gen3x(2,1,nt)]
 q0 = p0 + dr
 q1 = p1 + r*([cos(dtheta),sin(dtheta)])

; plots, [p0[0],p1[0]], [p0[1],p1[1]]
; plots, [q0[0],q1[0]], [q0[1],q1[1]], col=255
; plots, p0, psym=1
; plots, q0, psym=1, col=255


 ;-----------------------------------------------------
 ; get inertial vector pointing at each image point
 ;-----------------------------------------------------
 bd = cam_body(cdp)
 u0 = bod_body_to_inertial(bd, $
          cam_focal_to_body(cdp, $
             cam_image_to_focal(cdp, p0)))

 u1 = bod_body_to_inertial(bd, $
          cam_focal_to_body(cdp, $
             cam_image_to_focal(cdp, p1)))

 v0 = bod_body_to_inertial(bd, $
          cam_focal_to_body(cdp, $
             cam_image_to_focal(cdp, q0)))

 v1 = bod_body_to_inertial(bd, $
          cam_focal_to_body(cdp, $
             cam_image_to_focal(cdp, q1)))


 ;=========================================
 ; construct rotation axis and angle
 ;=========================================
 n = dblarr(1,3,nt, /nozero)
 cos_angle = dblarr(1,1,nt, /nozero)
 sin_angle = dblarr(1,1,nt, /nozero)


 ;-----------------------------------------
 ; no translation and no rotation
 ;-----------------------------------------
 w = where((dxy[0,0,*] EQ 0. AND dxy[1,0,*] EQ 0.) AND dtheta EQ 0.)
 if(w[0] NE -1) then $
  begin
   n[*,*,w]=u0[*,*,w]
   cos_angle[w]=1.0
   sin_angle[w]=0.0
  end

 ;-----------------------------------------
 ; rotation with no translation
 ;-----------------------------------------
 w = where((dxy[0,0,*] EQ 0. AND dxy[1,0,*] EQ 0.) AND dtheta NE 0.)
 if(w[0] NE -1) then $
  begin
   n[*,*,w] = u0[*,*,w]
   cos_angle[w] = cos(dtheta[w])
   sin_angle[w] = sin(dtheta[w])
  end

 ;-----------------------------------------
 ; translation with no rotation
 ;-----------------------------------------
 w = where((dxy[0,0,*] NE 0. OR dxy[1,0,*] NE 0.) AND dtheta EQ 0.)
 if(w[0] NE -1) then $
  begin
   nw = n_elements(w)

   n[*,*,w] = v_cross(u0[*,*,w], u1[*,*,w])

   sin_angle[w] = v_mag(n[*,*,w])
   cos_angle[w] = sqrt(1-sin_angle[w]^2)

   n[*,*,w] = n[*,*,w]/(sin_angle[w])[linegen3y(1,3,nw)]
  end

 ;-------------------------------------------------------------------
 ; translation and rotation - 
 ;      this is not working correctly for multiple time steps.
 ;-------------------------------------------------------------------
 w = where((dxy[0,0,*] NE 0. OR dxy[1,0,*] NE 0.) AND dtheta NE 0.)
 if(w[0] NE -1) then $
  begin
   nw = n_elements(w)

   n[*,*,w] = v_unit(v_cross(u1[*,*,w]-u0[*,*,w], v1[*,*,w]-v0[*,*,w]))

;   u0_dot_n = v_inner(u0[*,*,w],n[*,*,w])
   u0_dot_n = reform(v_inner(u0[*,*,w],n[*,*,w]), 1,1,nt, /overwrite)
   sign = sign(u0_dot_n)*sign(dtheta[w])

   u0_dot_n = u0_dot_n[linegen3y(1,3,nw)]

   cos_angle[w] = (v_inner(u0[*,*,w],u1[*,*,w]) - $
                            u0_dot_n^2)/v_sqmag(u0[*,*,w] - n[*,*,w]*u0_dot_n)
   sin_angle[w] = sign*sqrt(1 - cos_angle^2)
  end


 ;-----------------------------------------
 ; replicate for each basis vector
 ;-----------------------------------------
 n = n[linegen3x(3,3,nt)]
 gen = linegen3x(3,1,nt)
 cos_angle = cos_angle[gen]
 sin_angle = -sin_angle[gen]


 ;-----------------------------
 ; rotate orientation matrices
 ;-----------------------------
 bod_set_orient, bd, v_rotate_11(bod_orient(bd), n, [sin_angle], [cos_angle])


 if(reformed) then _cdp=reform(cdp, 1, nt) $
 else _cdp=cdp

end
;===========================================================================
