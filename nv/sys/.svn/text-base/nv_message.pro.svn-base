;=============================================================================
;	NOTE:	remove the second '+' on the next line for this header
;		to be recognized by extract_doc.
;++
; NAME:
;	nv_message
;
;
; PURPOSE:
;	Issues error and informational messages.
;
;
; CATEGORY:
;	NV/SYS
;
;
; CALLING SEQUENCE:
;	nv_message, message, name=name
;
;
; ARGUMENTS:
;  INPUT:
;	xx:	xx
;
;	xx:	xx
;
;  OUTPUT:
;	xx:	xx
;
;	xx:	xx
;
;
; KEYWORDS:
;  INPUT:
;	xx:	xx
;
;	xx:	xx
;
;  OUTPUT:
;	xx:	xx
;
;	xx:	xx
;
;
; RETURN:
;	xx
;
;
; COMMON BLOCKS:
;	xx:	xx
;
;	xx:	xx
;
;
; SIDE EFFECTS:
;	xx
;
;
; RESTRICTIONS:
;	xx
;
;
; PROCEDURE:
;	xx
;
;
; EXAMPLE:
;	xx
;
;
; STATUS:
;	xx
;
;
; SEE ALSO:
;	xx, xx, xx
;
;
; MODIFICATION HISTORY:
; 	Written by:	xx, xx/xx/xxxx
;	
;-
;=============================================================================
pro nv_message, message, name=name, continue=continue, $
             clear=clear, get_message=get_message, message=_message, $
             callback=callback, cb_data_p=cb_data_p, disconnect=disconnect, $
             cb_tag=cb_tag, silent=_silent
common nv_message_block, last_message, cb_tlp, silent
@nv.include

 silent = keyword_set(silent)

 if(defined(_silent)) then silent = _silent

 ;------------------------------------------------
 ; manage callbacks
 ;------------------------------------------------
 if(keyword_set(cb_tag)) then $
  begin
   if(keyword_set(disconnect)) then tag_list_rm, cb_tlp, cb_tag $
   else $
    begin
     data_p = ptr_new()
     if(keyword_set(cb_data_p)) then data_p = cb_data_p
     data = {callback:callback, data_p:data_p}
     tag_list_set, cb_tlp, cb_tag, data
    end
   return
  end

 ;--------------------------------------------------
 ; make sure stored message has a defined value
 ;--------------------------------------------------
 if(NOT keyword_set(last_message)) then last_message = ''

 ;--------------------------------------------------
 ; if /clear, just discard last message
 ;--------------------------------------------------
 if(keyword_set(clear)) then $
  begin
   last_message = ''
   return
  end

 ;--------------------------------------------------
 ; if /get_message, just return with last message
 ;--------------------------------------------------
 if(keyword_set(get_message)) then $
  begin
   _message = last_message
   return
  end

 ;---------------------------------------------------------------
 ; otherwise, store last message and print to terminal
 ;---------------------------------------------------------------
 if(NOt keyword_set(message)) then return
 last_message = message
 if(keyword_set(name)) then message = strupcase(name)+': ' + message
 if((NOT silent) AND (NOT ptr_valid(cb_tlp))) then message, message, /continue, /noname
 if(NOT keyword_set(continue)) then retall


 ;----------------------------------------------------
 ; call callbacks
 ;----------------------------------------------------
 if(ptr_valid(cb_tlp)) then $
  begin
   list = *cb_tlp
   n = n_elements(list)
   for i=0, n-1 do $
    begin
     data = tag_list_get(cb_tlp, index=i)
     call_procedure, data.callback, data.data_p, message
    end
  end


end
;===========================================================================
