;=======================================================================
;                            MOSAIC.EXAMPLE
;
;  This example requires the following kernel files, which are not 
;  supplied with the default distribution:
;   $NV_SPICE_CK/001103_001105ra.bc
;   $NV_SPICE_CK/001105_001108.bc
;   $NV_SPICE_CK/001026_001029ra.bc
;   $NV_SPICE_CK/001029_001031ra.bc
;
;  This example file demonstrates how to construct a mosaic using MINAS.
;  For more thorough annotations, please see jup_cassini.example and 
;  dione.example.
;
;  This example file can be executed from the UNIX command line using
;
;  	idl minas mosaic.example
;
;  or from within IDL using
;
;  	@mosaic.example
;
;  After the example stops, later code samples in this file may be executed by
;  pasting them onto the IDL command line.
;
;=======================================================================
!quiet = 1
zoom = 0.3

;-------------------------------
; load files
;-------------------------------
;files = ['./data/n1350122987.2', $
;         './data/n1351469359.2', $
;         './data/n1351523119.2', $
;         './data/n1352037683.2']
files = ['./data/n1350122987.2', $
         './data/n1351469359.2']
n = n_elements(files)

dd = nv_read(files, input_transform='cas_delut')


;---------------------------------------
; get ancillary info for each image
;---------------------------------------
_gd = {cd:ptr_new(), gbx:ptr_new(), dkx:ptr_new(), sund:ptr_new()}
gd = replicate(_gd, n)

for i=0, n-1 do gd[i].cd = pg_get_cameras(dd[i])
for i=0, n-1 do $
       gd[i].gbx = pg_get_planets(dd[i], od=gd[i].cd, plt_name='JUPITER')
for i=0, n-1 do gd[i].dkx = pg_get_rings(dd[i], pd=gd[i].gbx, od=gd[i].cd)
for i=0, n-1 do gd[i].sund = pg_get_stars(dd[i], od=gd[i].cd, str_name='SUN')


;---------------------------------------------------
; display images and keep track of window numbers
;---------------------------------------------------
for i=0, n-1 do tvim, nv_data(dd[i]), zoom=zoom, /order, /new
tvim, /list, wnum=ww


;-------------------------------
; compute initial limbs
;-------------------------------
limb_ps = replicate({pg_points_struct}, n)
for i=0, n-1 do limb_ps[i] = pg_limb(gd=gd[i]) 


;-----------------------------------------------------------------------
; Navigate on limbs automatically
;
; pg_farfit finds the limb to within a few pixels.  In reality, you would 
; want to refine the pointing by scanning for the limb and performing a
; least-squares fit, but for the purposes of clarity in this example, the 
; inital fit will do.  See jup_cassini.example and dione.example for examples 
; of least-squares fits to image features.
;
;-----------------------------------------------------------------------
edge_ps = replicate({pg_points_struct}, n)
for i=0, n-1 do edge_ps[i] = pg_edges(dd[i], edge=10)

dxy = dblarr(2,n)
for i=0, n-1 do dxy[*,i] = pg_farfit(dd[i], edge_ps[i], [limb_ps[i]], ns=[5,5])
for i=0, n-1 do pg_repoint, dxy[*,i], 0d, gd=gd[i]


;--------------------------------------------------------
; recompute and redisplay limbs using corrected pointing
;--------------------------------------------------------
for i=0, n-1 do limb_ps[i] = pg_limb(gd=gd[i]) 
for i=0, n-1 do  pg_draw, limb_ps[i], wnum=ww[i]

;---------------------------------------------------------------------
; Correct photometry
;
; By default, pg_photom uses a minneart photometric function, but other
; functions and their parameters can be specified.  Here, a crude 
; photometric correction is performed for the purposes of this example.
;
; In addition to the corrected images, the output descriptors, dd_pht, 
; will contain the photometric angles in their user data arrays with
; the names 'EMM', 'INC' and 'PHASE'.
;
;----------------------------------------------------------------------
dd_pht = ptrarr(n)
for i=0, n-1 do dd_pht[i] = pg_photom(dd[i], gd=gd[i], $
;                                      refl_parm=[0.65d], outline=limb_ps[i]) 
                                      refl_parm=[0.75d], outline=limb_ps[i]) 

for i=0, n-1 do tvim, nv_data(dd_pht[i]), ww[i]



;------------------------------------------------------------------------------
; Project maps
;
; Note that all map projections use the same map descriptor.
;
; Also, aux=['EMM'] is used with pg_map to direct it to reproject
; the emmision angle array that was produced and stored in the data descriptor
; by pg_photom.  That array will be needed by pg_mosaic.
; 
;------------------------------------------------------------------------------
map_xsize = 800
map_ysize = 400


md = pg_get_maps(/over, gbx = pd1, $
	map_name='JUPITER',$
	map_type='RECTANGULAR', $
	map_fn_data=ptr_new(), $
	map_size=[map_xsize,map_ysize], $
	map_origin=[map_xsize,map_ysize]/2 $
	)

;md = pg_get_maps(/over, gbx=pd1, $
;	map_name='JUPITER',$
;	map_type='ORTHOGRAPHIC', $
;;	map_type='STEREOGRAPHIC', $
;	map_fn_data=ptr_new(), $
;;	map_center=[!dpi/2d,0], $	; polar
;	map_center=[!dpi/4d,0], $
;	map_size=[map_xsize,map_ysize], $
;	map_origin=[map_xsize,map_ysize]/2 $
;	)

;md = pg_get_maps(/over, gbx=pd1, $
;	map_name='JUPITER',$
;;	map_type='MOLLWEIDE', $
;	map_type='MERCATOR', $
;	map_fn_data=ptr_new(), $
;	map_size=[map_xsize,map_ysize], $
;	map_origin=[map_xsize,map_ysize]/2 $
;	)


dd_map = ptrarr(n)
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; Use the commented commands instead to include a zonal wind profile in
; the projection.
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
for i=0, n-1 do dd_map[i] = pg_map(dd_pht[i], md=md, gd=gd[i], aux=['EMM'])

;for i=0, n-1 do $
;   dd_map[i] = pg_map(dd_pht[i], md=md, gd=gd[i], aux=['EMM'], $
;                   wind_fn='pm_wind_zonal', $
;                   wind_data={vel:cos((dindgen(181)-90)*!dpi/180d) * 100d, $
;                              dt:bod_time(gd[i].cd)-bod_time(gd[0].cd)})

for i=0, n-1 do tvim, nv_data(dd_map[i]), /new


;----------------------------------------------------------------------
; Construct the mosaic
;
;  The combination function 'pgms_combine_emm' combines the maps
;  using wighting proprtional to emm^x, where emm is the emmision 
;  cosine.  It also imposes a minimum emmision cosine, emm0.  Here,
;  we set x=5 and emm0=cos(85 deg).
;
;----------------------------------------------------------------------
;dd_mosaic = pg_mosaic(dd_map, mosaic=mosaic, $
;               combine='pgms_combine_emm', data={x:5, emm0:cos(85d*!dpi/180d)})
dd_mosaic = pg_mosaic(dd_map, mosaic=mosaic, $
               wt='pgms_wt_emm', comb='pgms_combine_sum', data={x:5, emm0:cos(85d*!dpi/180d)})
tvim, mosaic, /new



stop, '=== Auto-example complete.  Use cut & paste to continue.'

;----------------------------------------------------------------------
; Save the mosaic and map info
;
; To read the mosaic and projection info:
;
;  dd = nv_read('./data/test.msc', mosaic, label)
;  md = pg_get_maps(dd)
;
;----------------------------------------------------------------------
pg_put_maps, dd_mosaic, md=md
nv_write, './data/test.mos', dd_mosaic, filetype = 'VICAR'







